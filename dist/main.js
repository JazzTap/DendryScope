/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src lazy recursive ^.*.*$":
/*!**************************************************!*\
  !*** ./src/ lazy ^.*.*$ strict namespace object ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./8d0508ea75589ad1@4544.js\": \"./src/8d0508ea75589ad1@4544.js\",\n\t\"./a33468b95d0b15b0@808.js\": \"./src/a33468b95d0b15b0@808.js\",\n\t\"./index.js\": \"./src/index.js\",\n\t\"./runtime.js\": \"./src/runtime.js\"\n};\n\nfunction webpackAsyncContext(req) {\n\treturn Promise.resolve().then(() => {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\n\t\tvar id = map[req];\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./src lazy recursive ^.*.*$\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://@jazztap/dendryscope-demo/./src/_lazy_^.*.*$_strict_namespace_object?");

/***/ }),

/***/ "./src/8d0508ea75589ad1@4544.js":
/*!**************************************!*\
  !*** ./src/8d0508ea75589ad1@4544.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ define)\n/* harmony export */ });\n/* harmony import */ var _a33468b95d0b15b0_808_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a33468b95d0b15b0@808.js */ \"./src/a33468b95d0b15b0@808.js\");\n\n      function getAbsoluteUrl(relativeUrl) {\n        const publicPath = __webpack_require__.p;\n\n        let url = '';\n\n        if (!publicPath || publicPath.indexOf('://') < 0) {\n          url += window.location.protocol + '//' + window.location.host;\n        }\n\n        if (publicPath) {\n          url += publicPath;\n        } else {\n          url += '/';\n        }\n\n        return url + relativeUrl;\n      }\n\nfunction _1(md) {\n  return md`# Dendryscope Demo\n- [Bee](https://inthewalls.itch.io/bee) (2012, Emily Short) [[source]](https://github.com/dendry/bee)\n- [Clingo](https://teaching.potassco.org/) (via Dominic Moritz's WASM port) [[demo]](https://observablehq.com/@cmudig/clingo)  `;\n}\nfunction _legendSwatches(Swatches, colorByTag) {\n  return Swatches(colorByTag);\n}\nfunction _3(html, legendSwatches, hoverPredicate) {\n  return html`<div style=\"display: grid; grid-template-columns: 1fr 1fr;\">${legendSwatches} <div>I can see ${hoverPredicate[0]} at step ${hoverPredicate[1]}</div></div>`;\n}\nfunction _peek(html, width, d3, xScale, steps, horizon, Event, $0, visibilityChart) {\n  const ret = html`<svg width=${width} height=100></svg>`; // .attr(\"viewBox\", [350, 0, width - 200, 80]),\n  const svg = d3.select(ret);\n  const brush = d3.brushX().extent([[0, 0], [width + 20, 60]]).on(\"start brush end\", brushed);\n  const x = step => 1.2 * xScale(step) - 300;\n  const xInvert = pos => xScale.invert(pos / 1.2 + 300);\n\n  // count of possible choices at given timestep\n  let weights = Array.from(d3.group(steps, d => d[1])).map(d => [+d[0], d[1].length]);\n  const h = d => Math.pow(d[1], 0.66) * 5;\n  const w = x(1) - x(0);\n  const xAxis = g => g.attr(\"transform\", `translate(${w / 2 - 300},60) scale(1.2,1)`).call(d3.axisTop(xScale));\n  const weight = svg.append(\"g\").selectAll(\"rect\").data(weights).join(\"rect\").attr(\"x\", d => x(d[0])).attr(\"width\", w - 2).attr(\"y\", d => 2 + (60 - h(d)) / 2).attr(\"height\", h).attr(\"fill\", d => d[1] == 1 ? \"#000\" : \"#888\");\n  svg.append(\"g\").call(xAxis);\n  svg.append(\"g\").call(brush).call(brush.move, [0.5, horizon + 0.5].map(i => x(i))).call(g => g.select(\".overlay\").datum({\n    type: \"selection\"\n  }).on(\"mousedown touchstart\", beforebrushstarted));\n  function beforebrushstarted(event) {\n    const dx = x(horizon) - x(0); // Use a fixed width when recentering.\n    const [[cx]] = d3.pointers(event);\n    const [x0, x1] = [cx - dx / 2, cx + dx / 2];\n    const [X0, X1] = x.range();\n    d3.select(this.parentNode).call(brush.move, x1 > X1 ? [X1 - dx, X1] : x0 < X0 ? [X0, X0 + dx] : [x0, x1]);\n  }\n  function brushed(event) {\n    const selection = event.selection;\n    if (selection === null) {\n      weight.attr(\"stroke\", null);\n    } else {\n      const [x0, x1] = selection.map(xInvert).map(k => Math.floor(k));\n      weight.attr(\"stroke\", d => x0 <= d && d <= x1 ? \"red\" : null);\n      ret.value = [Math.max(x0, 0), x1];\n      ret.dispatchEvent(new Event(\"input\"));\n      $0.value = d3.scaleLinear(ret.value, [150, width - 120]);\n      visibilityChart.redraw();\n    }\n  }\n  $0.value = d3.scaleLinear(ret.value, [150, width - 120]);\n  return ret;\n}\nfunction _visibilityChart(legend, html, d3, colorByTag, legendTags, $0, $1, stepFrequencies, $2, $3, $4, steps, $5) {\n  let height = Math.max(...Object.values(legend));\n  let ret = html`\n<div style=\"display: grid; grid-template-columns: 155px 1fr;\">\n  <div id=\"labels\" style=\"height: 400px; width: 145px; overflow-y: scroll; overflow-x: hidden;\">\n    <svg width=145 height=${height}></svg>\n  </div>\n  <div id=\"steps\" style=\"height: 400px; overflow-y: scroll; overflow-x: hidden;\">\n    <svg width=1500 height=${height}>\n     <g id=\"steps\"></g>\n      <g id=\"pins\"></g>\n    </svg>\n  </div>\n</div>`;\n  let labelsContainer = d3.select(ret).select(\"div#labels\");\n  let labels = labelsContainer.select(\"svg\").selectAll(\"text\").data(Object.entries(legend).filter(d => d[0] !== \"enter\")).join(\"text\").attr(\"x\", 0).attr(\"y\", d => d[1] + 10)\n  // .text((d) => (d[0][0] == \"n\" ? \"\" : d[0]))\n  // .text((d) => d[0])\n  .attr(\"font-size\", \"14\").attr(\"fill\", d => colorByTag(legendTags[d[0]])).on(\"click\", function (e, d) {\n    if ($0.value.includes(d[0])) {\n      $1.value.push(d[0]);\n      $0.value.splice($0.value.indexOf(d[0]), 1);\n    } else if ($1.value.includes(d[0])) {\n      $1.value.splice($0.value.indexOf(d[0]), 1);\n    } else {\n      $0.value.push(d[0]);\n    }\n    $0.value = $0.value;\n    $1.value = $1.value;\n    redraw();\n  });\n  let counts = stepFrequencies,\n    maxCount = Math.max(...counts);\n\n  // CHART\n  // let boxFill = (d) => (d[0][0] == \"n\" ? \"gray\" : \"black\");\n  let boxFill = (d, i) => counts[i] == 0 ? \"#eee\" : d3.interpolateBlues(Math.sqrt(counts[i]) / Math.sqrt(maxCount));\n  let sel = d3.select(ret).select(\"div#steps\");\n  // linked scrolling between labels and playtraces\n  labelsContainer.on(\"scroll\", function (e) {\n    sel.node().scrollTop = this.scrollTop;\n  });\n  sel.on(\"scroll\", function (e) {\n    labelsContainer.node().scrollTop = this.scrollTop;\n  });\n  function redraw() {\n    //  horizontal scroll and extent\n    let x = $2.value;\n    blocks.attr(\"x\", d => x(d[1]) - 150).attr(\"width\", x(1) - x(0) - 1);\n    // required / forbidden scenes\n    labels.attr(\"text-decoration\", d => $0.value.includes(d[0]) ? \"underline\" : $1.value.includes(d[0]) ? \"line-through\" : \"none\").text(d => `${d[0]} ${$0.value.includes(d[0]) ? \"ðŸ”’\" : $1.value.includes(d[0]) ? \"ðŸš«\" : \"\"}`);\n    // pinned beats\n    // console.log(mutable pinnedNodes[0].split(\",\"));\n    pins.selectAll(\"ellipse\").data([...$3.value.map(s => [...s.split(\",\"), \"\"]), ...$4.value.map(s => [...s.split(\",\"), \"cut\"])]) // DUPE\n    .join(\"ellipse\").attr(\"cy\", d => legend[d[0]] + 4.5).attr(\"cx\", d => x(d[1]) - 150 + (x(1) - x(0)) / 2).attr(\"rx\", 4).attr(\"ry\", 4).attr(\"fill\", d => d[2] ? \"#fff\" : \"#acf\").attr(\"stroke\", d => d[2] ? \"#000\" : \"#59f\").attr(\"stroke-width\", 3).style(\"pointer-events\", \"none\");\n  }\n  let blocks = sel.select(\"svg\").select(\"g#steps\").selectAll(\"rect\").data(steps).join(\"rect\").attr(\"y\", d => legend[d[0]])\n  // .attr(\"height\", (d) => (d[0][0] == \"n\" ? 8 : 22))\n  .attr(\"height\", 9).style(\"fill\", boxFill).on(\"mouseenter\", function (e, d) {\n    $5.value = d;\n    d3.select(this).style(\"stroke\", \"darkgray\");\n  }).on(\"mouseleave\", function (e, d) {\n    d3.select(this).style(\"stroke\", \"none\");\n  }).on(\"mousedown\", function (e, d) {\n    let s = d.join(\",\");\n    if ($3.value.includes(s)) {\n      $4.value.push(s);\n      $3.value.splice($3.value.indexOf(s), 1);\n    } else if ($4.value.includes(s)) {\n      $4.value.splice($4.value.indexOf(s), 1);\n    } else $3.value.push(s); // mutable forcedNodes.push(s)\n\n    $4.value = $4.value;\n    redraw();\n  });\n  let pins = sel.select(\"svg\").select(\"g#pins\");\n  redraw();\n  return Object.assign(ret, {\n    redraw\n  });\n}\nfunction _controlBox(html, $0, $1, $2) {\n  return html`<div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr;\">${$0} ${$1} ${$2}</div>`;\n}\nasync function _inspectorBox(html, makeCard, scene, sceneVersion, makeStateChart) {\n  return html`<div style=\"display: grid; grid-template-columns: 1fr 1fr;\">\n${makeCard(scene, sceneVersion)}\n${await makeStateChart()}\n</div>`;\n}\nfunction _9(sceneVersion) {\n  return sceneVersion;\n}\nfunction _qPreview(DendryQuery, requiredNodes, forbiddenNodes, pinnedNodes, forcedNodes, $0, $1) {\n  return new DendryQuery({\n    require: requiredNodes,\n    forbid: forbiddenNodes,\n    pin: pinnedNodes,\n    // viewof pinnedSteps.value,\n    force: forcedNodes\n  }, $0.value, $1.value, \"previewOnly\");\n}\nfunction _queryPreview(qPreview) {\n  return [qPreview.forceString, qPreview.argumentString].join(\"\\n\").trim();\n}\nfunction _pinnedNodes() {\n  return [];\n}\nfunction _forcedNodes() {\n  return [];\n}\nfunction _requiredNodes() {\n  return [];\n}\nfunction _forbiddenNodes() {\n  return [];\n}\nfunction _q(doQuery, DendryQuery, $0, $1, $2, $3, $4, $5) {\n  doQuery;\n  return new DendryQuery({\n    require: $0.value,\n    forbid: $1.value,\n    pin: $2.value,\n    // viewof pinnedSteps.value,\n    force: $3.value\n  }, $4.value, $5.value);\n}\nfunction _browseTag(Inputs, scenes) {\n  return Inputs.select([...new Set(scenes.map(u => u.tags))], {\n    value: \"top\"\n  });\n}\nfunction _18(md, scenes, browseTag, d3) {\n  let ret = md`${scenes.filter(s => s.tags == browseTag).map(s => `##### ${s.title}\n${s.label}  \n${s.subtitle}`).join(\"\\n\\n\")}`;\n  d3.select(ret).style(\"height\", \"200px\").style(\"overflow-y\", \"scroll\");\n  return ret;\n}\nfunction _xScale(d3, horizon, width) {\n  return d3.scaleLinear([1, horizon], [360, width - 10]);\n}\nfunction _horizon(Inputs) {\n  return Inputs.range([1, 30], {\n    label: \"run for this many timesteps\",\n    step: 1,\n    value: 5\n  });\n}\nfunction _timeout(Inputs) {\n  return Inputs.range([0, 30000], {\n    label: \"give up after this many ms\",\n    step: 1000,\n    value: 2000\n  });\n}\nfunction _doQuery(html) {\n  return html`<button>Run</button>`;\n}\nfunction _debug() {\n  return [];\n}\nfunction _makeStateChart(hasSeen, hoverPredicate, mungePredicate, html, d3, $0, $1) {\n  return async function makeStateChart() {\n    let worlds = (await hasSeen(hoverPredicate)).map(state => state.map(s => mungePredicate(s, false)));\n    let raw = worlds.map(state => state.filter(s => s[0] == \"reaches\"));\n\n    // HACK: melt together all traces that get here\n    let steps = [...new Set(raw.map(arr => arr.map(tup => tup.join(\",\"))).flat(1))].map(s => s.split(\",\"));\n    let legend = Object.fromEntries([...new Set(steps.map(d => d[1]))].sort().map((s, i) => [s, 5 + i * 20]));\n    let ret = html`<div style=\"height: 600px; overflow-x: hidden;\">\n<svg width=800 height=${Object.keys(legend).length * 20 + 10}></svg></div>`;\n    d3.select(ret).select(\"svg\").selectAll(\"text\").data(Object.entries(legend)).join(\"text\").attr(\"x\", 0).attr(\"y\", d => d[1] + 10).text(d => d[0]).attr(\"font-size\", \"10\");\n    let counts = steps.map(d => hasSeen(d).length),\n      maxCount = Math.max(...counts);\n\n    // CHART\n    // let boxFill = (d) => (d[0][0] == \"n\" ? \"gray\" : \"black\");\n    let boxFill = (d, i) => d3.interpolateGreys((counts[i] + 50) / maxCount);\n    d3.select(ret).select(\"svg\").append(\"line\").attr(\"x1\", 100).attr(\"x2\", 100).attr(\"y1\", 0).attr(\"y2\", Object.keys(legend).length * 20).style(\"stroke\", \"black\");\n    d3.select(ret).select(\"svg\").selectAll(\"rect\").data(steps).join(\"rect\").attr(\"x\", d => 100 + +d[2] * 30).attr(\"width\", 25).attr(\"y\", d => legend[d[1]]).attr(\"height\", 18).style(\"fill\", boxFill).on(\"click\", (e, d) => {\n      $0.value = worlds.find(state => state.find(u => u[1] == d[1] && u[2] == d[2]));\n      $1.value = Math.max(...$0.value.filter(p => p[0] == \"visited\").map(p => p[2])) + 5;\n    });\n    return ret;\n  };\n}\nfunction _traceBuilder() {\n  return null;\n}\nfunction _hoverPredicate() {\n  return [];\n}\nfunction _filterIndex(Inputs, visibility) {\n  return Inputs.range([1, visibility.length], {\n    label: \"threshold of brave enumeration steps\",\n    step: 1,\n    value: visibility.length,\n    disabled: true\n  });\n}\nfunction _xSelection(xScale) {\n  return xScale;\n}\nfunction _getLabels() {\n  return u => {\n    return typeof u == \"object\" ? Object.keys(u).filter(s => s[0] == \"@\") : [];\n  };\n}\nfunction _30(md) {\n  return md`### domain synthesis\ningests: an abstract syntax tree representing all dendry scenes`;\n}\nfunction _scenes(ast, getLabels) {\n  let ret = ast;\n  let entitle = (node, nodeIndex) => {\n    node[\"label\"] = node[\"title\"] ? node[\"title\"].replaceAll(\" \", \"_\").replaceAll(\"'\", \"\") // TODO: strip punctuation in general\n    .replaceAll(\".\", \"\").replaceAll(\"?\", \"\").replaceAll(\"-\", \"\").toLowerCase() : \"enter\"; // very load-bearing. 'hub(enter)' appears in the domain dict by fiat.\n\n    // attach labels to each choice present\n    let choices = getLabels(node); // all children except leaf nodes (not in AST)\n    let allChoices = [...choices];\n\n    // HACK: gather up nodes missing from AST\n    node[\"choices\"] = getLabels(node[node[\"title\"]]); // all first children\n    node[\"choices\"].forEach(s_ => {\n      if (!choices.includes(s_)) allChoices.push(s_);\n    });\n    if (node[\"go-to\"]) allChoices.push(...node[\"go-to\"].split(\"; \").map(s => \"@\" + s));\n\n    // DUPE: repeat for each node in the scene\n    choices.forEach(s => {\n      node[s][\"choices\"] = getLabels(node[s]);\n      node[s][\"choices\"].forEach(s_ => {\n        if (!choices.includes(s_)) allChoices.push(s_);\n      });\n      if (node[s][\"go-to\"]) allChoices.push(...node[s][\"go-to\"].split(\"; \").map(s => \"@\" + s));\n    });\n    allChoices.forEach(s => {\n      node[s] = node[s] || {\n        choices: []\n      }; // create blanks for leaf nodes\n\n      // BRITTLE: generate unique node ids\n      node[s][\"label\"] = \"n\" + nodeIndex + \"_\" + s.slice(1).replaceAll(\"-\", \"_\").split(\" \").slice(0, 1);\n    });\n    // VERIFY: handle forced choices\n    if (node[\"go-to\"]) node[\"choices\"].push(...node[\"go-to\"].split(\"; \").map(s => `@${s}`));\n    return node;\n  };\n  return ret.filter(node => node[\"is-special\"] === undefined).map(entitle);\n}\nfunction _egress() {\n  return node => node[\"go-to\"] ? node[\"go-to\"].split(\"; \").map(s => \"@\" + s) // HACK: a lil' parsing for probabilistic gotos\n  : node[\"choices\"];\n}\nfunction _labelsIn() {\n  return s => {\n    let idxs = Object.keys(s).filter(k => k[0] == \"@\");\n    return [s[\"label\"], ...idxs.map(k => s[k][\"label\"])];\n  };\n}\nfunction _nodesIn() {\n  return (s, inclusive = false) => {\n    let idxs = Object.keys(s).filter(k => k[0] == \"@\");\n    let ret = idxs.map(k => s[k]);\n    return inclusive ? [s, ...ret] : ret;\n  };\n}\nfunction _nodes(scenes, labelsIn) {\n  return scenes.map(s => labelsIn(s)).flat();\n}\nfunction _linksIn(egress) {\n  return s => {\n    let idxs = Object.keys(s).filter(k => k[0] == \"@\");\n    return [...egress(s).map(tar => [s.label, s[tar].label]), ...idxs.map(k => egress(s[k]).map(tar => [s[k].label, s[tar].label])).flat()];\n  };\n}\nfunction _leavesIn(egress) {\n  return s => {\n    let idxs = Object.keys(s).filter(k => k[0] == \"@\");\n    // return idxs.filter((k) => s[k].choices.length == 0).map((k) => s[k][\"label\"]);\n\n    let ret = idxs.filter(k => egress(s[k]).length == 0);\n    return idxs.length == 0 ? [s.label] : ret;\n  };\n}\nfunction _mungeOpsTree() {\n  return opDict => ast => {\n    if (ast === undefined) return [];\n    let sanitize = key => key.replaceAll(\"-\", \"_\");\n    return Object.entries(ast).map(([op, kv]) => Object.entries(kv).map(([k, v]) => [sanitize(k), opDict[op], v])).flat();\n  };\n}\nfunction _sceneVersion(scenesExpanded, hoverPredicate) {\n  return scenesExpanded.flat().find(s => s.label == hoverPredicate[0]);\n}\nfunction _scene(scenes, labelsIn, hoverPredicate) {\n  // let s = { ...scenes.find((s) => !s.title) };\n  let s = {\n    ...scenes.find(s => labelsIn(s).includes(hoverPredicate[0].split(\"_\").slice(1).join(\"_\")))\n\n    // ...scenes[46] // A Call to Arms\n    // ...scenes.find((s) => (s.title ? s.title.includes(\"Seen\") : false)) // TODO: 'heard rather than seen' has a conditional go-to\n    // ...scenes.find((s) => (s.title ? s.title.includes(\"Church\") : false))\n    // ...scenes.find((s) => (s.title ? s.title.includes(\"Hawaii\") : false))\n    // ...scenes[30] // hub scene\n  };\n\n  return s;\n}\nfunction _makeCard(html, d3, steps, scenesIndex, stepFrequencies, commonVariables) {\n  return function (scene, version) {\n    const res = html`<div style=\"margin: 5px 10px; border-left: solid lightgray 4px; height: 600px; overflow-y: scroll;\"></div>`;\n    const flattenOps = opsDict => {\n      if (!opsDict) return [];\n      return Object.entries(opsDict).reduce((arr, [op, pairs]) => {\n        Object.entries(pairs).forEach(([k, v]) => arr.push(`${k} ${op} ${v}`));\n        return arr;\n      }, []);\n    };\n    const follows = (ast, ptr) => {\n      if (!ptr) return ast.choices;\n      let choices = ast[ptr].choices;\n      if (!choices.length) {\n        if (ast[ptr][\"go-to\"]) return ast[ptr][\"go-to\"].split(\"; \").map(s => `@${s}`);\n        return [];\n      }\n      return choices;\n    };\n    const hasSeen = [];\n    function makeTree(sel, ast, ptr = null, depth = 0) {\n      const children = follows(ast, ptr);\n\n      // don't expand the same label twice, if the scene fans in\n      // FIXME: dupes title style\n      if (hasSeen.includes(ptr)) return sel.html(`<div style=\"padding-left: ${depth * 15}px; font-variant: small-caps; font-size: .8rem;\">${ast[ptr] ? ast[ptr].label : \"oops\"}</div>`);\n      sel.call(makeScene, ptr ? ast[ptr] : ast, depth * 15);\n      hasSeen.push(ptr);\n      if (!children.length) return sel;\n      return sel.append(\"div\").selectAll(\"div\").data(children).join(\"div\").each(function (s) {\n        makeTree(d3.select(this), ast, s, depth + 1);\n      });\n    }\n    const lookup =\n    // aggregate steps by label\n    steps.reduce((acc, d, i) => {\n      let nodesSeen = (scenesIndex.find(s => s.label == d[0]) || []).map(n => n.label);\n      nodesSeen.forEach(l => {\n        if (acc[l]) acc[l] += stepFrequencies[i];else acc[l] = stepFrequencies[i];\n      });\n      return acc;\n    }, {});\n    function makeScene(sel, choice, indent = 0) {\n      const pre = flattenOps({\n          ...choice[\"view-if\"],\n          ...choice[\"choose-if\"]\n        }),\n        post = flattenOps(choice[\"on-arrival\"]);\n      const s = choice.label;\n      const titleColor =\n      // highlight nodes in grey if possible, and in blue if observed\n      lookup[s] === undefined ? \"#fff\" : lookup[s] === 0 ? \"#eee\" : \"#def\";\n      const fontWeight = version.filter(u => u.label == s).length > 0 ? \"bold\" : \"normal\";\n\n      // TODO: these ids aren't unique! they should be classes\n      sel.html(`<div style=\"padding-left: ${indent}px;\">\n<div id=\"title\" style=\"height: 20px; margin: 0px 5px; font-variant: small-caps; font-size: .8rem; border-bottom: solid black 1px; overflow: hidden; background-color: ${titleColor}; font-weight: ${fontWeight};\">${choice.title || choice.label}</div>\n<div style=\"margin: 2px 8px; height: ${pre.length && post.length ? 50 : pre.length || post.length ? 20 : 5}px; display: grid; grid-template-rows: 1fr 1fr;\">\n  <div id=\"pre\" style=\"border-bottom: dashed gray 1px; font-size: .8rem;\"> </div>\n  <div id=\"post\" style=\"border-top: dashed gray 1px; font-size: .8rem;\"> </div>\n</div></div>`);\n      sel.select(\"#pre\") // preconditions\n      .selectAll(\"span\").data(pre).join(\"span\").text(d => d).style(\"color\", d => commonVariables.some(v => d.includes(v)) ? \"gray\" : \"black\").style(\"padding\", \".5rem\");\n      sel.select(\"#post\") // postconditions\n      .selectAll(\"span\").data(post).join(\"span\").text(d => d).style(\"color\", d => commonVariables.some(v => d.includes(v)) ? \"gray\" : \"black\").style(\"padding\", \".5rem\");\n    }\n    makeTree(d3.select(res), scene);\n    // makeScene(d3.select(res), scene);\n    return res;\n  };\n}\nfunction _commonVariables(variables, pres, scenes) {\n  return [...variables].filter(\n  // all variables in >25% of preconditions\n  v => pres.filter(sig => sig.includes(v)).length > scenes.length / 4);\n}\nfunction _earliestSeen(scenesIndex, steps) {\n  function earliestSeen(label) {\n    let node = scenesIndex.find(u => u.label == label);\n    if (node === undefined) return [label, -1];\n    let ret = steps.find(d => d[0] == node.label);\n    return [ret[0], +ret[1]];\n  }\n  let index = [...new Set(steps.map(d => d[0]))]; // DUPE\n  return Object.fromEntries(index.map(s => earliestSeen(s)).filter(out => out[1] !== -1).sort((lhs, rhs) => lhs[1] - rhs[1]));\n}\nfunction _legend(steps, scenesIndex, earliestSeen) {\n  let index = [...new Set(steps.map(d => d[0]))]; // all nodes occuring in the skein\n  let points = Object.fromEntries(index.map(s => [s, scenesIndex.findIndex(u => u.label == s)]));\n  let res = index.filter((u, i) => points[i] != -1).reduce((acc, s, i) => {\n    if (acc.scene == s.split(\"_\").slice(1).join(\"_\")) {\n      acc[0].push(s);\n    } else {\n      acc.scene = s.split(\"_\").slice(1).join(\"_\");\n      acc.unshift([acc.scene, s]);\n    }\n    // acc[points[s]] = [s]; // [...scenesIndex[points[s]].map((u) => u.label)].reverse();\n    return acc;\n  }, Object.assign([], {\n    scene: \"\"\n  }));\n\n  // produce a map from scene index -> labels in this scene\n  /* let ret = index.reduce((acc, s, i) => {\n    if (points[i] == -1) {\n      let idx = +s.split(\"_\")[0].slice(1); // retrieve parent index from stringified choice label\n      acc[idx].push(s);\n    }\n    return acc;\n  }, res); */\n\n  let offsets = res.sort((lhs, rhs) => earliestSeen[lhs[0]] - earliestSeen[rhs[0]]).reverse() // FIXME: wait, why?\n  .reduce((acc, labels) => {\n    if (acc.length == 0) return labels.map((s, i) => [s, i * 11]).reverse();\n    return [...labels.map((s, i) => [s, i * 11 + acc[0][1] + 20]).reverse(), ...acc];\n    // return [[s, acc[0][1] + (acc[0][0][0] == \"n\" ? 10 : 26)], ...acc];\n  }, []);\n  return Object.fromEntries(offsets);\n}\nfunction _colorByTag(d3, scenes) {\n  return d3.scaleOrdinal([\"virtual\", ...new Set(scenes.map(u => u.tags))].filter(u => u), d3.schemeTableau10);\n}\nfunction _legendTags(scenesIndex, legend, scenes) {\n  // TODO: refactor legend to separate y-position from node-flattening\n  let labels = scenesIndex.filter(u => Object.keys(legend).includes(u.label));\n  return Object.fromEntries([...labels.map(u => [u].map(v => [v.label, u.slice(-1)[0].tags])) // [u, ...nodesIn(u)]\n  .flat(1), ...scenes.map(u => [u.label, \"virtual\"])]);\n}\nasync function _visibility(q) {\n  try {\n    let res = await q.getFrontier();\n    return res.slice(-1)[0].filter(s => s.includes(\"visited\")); // \"visited\"\n  } catch {\n    return [];\n  }\n}\nfunction _steps(visibility, filterIndex, mungePredicate) {\n  return visibility.filter((s, i) => i < filterIndex).map(s => mungePredicate(s)).filter(d => d[0] !== \"enter\");\n}\nfunction _stepFrequencies(steps, hasSeen) {\n  return Promise.all(steps.map(async function (d) {\n    return (await hasSeen(d)).length;\n  }));\n}\nfunction _lastSceneCandidates(steps, horizon) {\n  return steps.filter(s => +s[1] > horizon - 5 && !Number.isInteger(+s[0][1]));\n}\nfunction _hasSeen(q) {\n  return async function (args) {\n    return (await q.getTraces()).filter(trace => trace.find(p => p == `visited(${args.join(\",\")})`));\n  };\n}\nfunction _mungePredicate() {\n  return (s, justArgs = true) => {\n    let getArgs = /([-\\w]+)\\(([-\\w,]+)\\)/;\n    let res = getArgs.exec(s);\n    if (justArgs) return res[2].split(\",\");\n    return [res[1], ...res[2].split(\",\")];\n    // return { predicate: res[1], args: res[2].split(\",\") };\n  };\n}\n\nfunction _DendryQuery(ruleString, domainString, run) {\n  return class DendryQuery {\n    constructor(constraint = {\n      require: [],\n      forbid: [],\n      pin: [],\n      force: []\n    }, horizon = 25, timeoutAfter = 3000, maxWorlds = 0,\n    // 100\n    maxTraces = 400,\n    // 200\n    previewOnly = false) {\n      if (!constraint.require) constraint.require = [];\n      if (!constraint.forbid) constraint.forbid = [];\n      if (!constraint.pin) constraint.pin = [];\n      if (!constraint.force) constraint.force = [];\n      this.argumentString = `\n  ${constraint.require.map(u => `goal(${u}).`).join(\"\\n\")}\n  ${constraint.forbid.map(u => `poison(${u}).`).join(\"\\n\")}\n  \n  quality(Q) :- wants(X,Q,Op,V).\n  quality(Q) :- sets(X,Q,Op,V).\n  has(Q,0,1) :- quality(Q). \n  \n  #const n=${horizon}.\n  `;\n      this.forceString = constraint.force.map(uv => `pin(${uv}).`).join(\"\\n\");\n      let frontierCode = [this.forceString, this.argumentString, ruleString, domainString].join(\"\\n\");\n      this.pinString = constraint.pin.map(uv => `pin(${uv}).`).join(\"\\n\");\n      let traceCode = [this.pinString, frontierCode].join(\"\\n\");\n      this.worker = previewOnly ? Promise.resolve({\n        frontier: null,\n        traces: null\n      }) : new Promise(async function (resolve, reject) {\n        // VERIFY: clingo-wasm doesn't want to run in parallel\n        console.log(\"running workers\");\n        let frontier = await run(frontierCode, maxWorlds, [\"--enum-mode=brave\"]);\n        let traces = await run(traceCode, maxTraces, []);\n        console.log(\"done\");\n        if (frontier.Result === \"ERROR\") reject(\"oops - frontier failed\");\n        if (traces.Result === \"ERROR\") reject(\"oops - trace failed\");\n        resolve({\n          frontier: frontier.Call[0].Witnesses.map(w => w.Value),\n          traces: traces.Call[0].Witnesses.map(w => w.Value)\n        });\n      });\n      this.timeout = new Promise(async function (resolve, reject) {\n        // await run; // on page load, don't start counting until wasm is ready\n        setTimeout(function () {\n          reject(\"Timed out after \" + timeoutAfter / 1000 + \"s\");\n          // resolve({ frontier: null, traces: null });\n          // {traces: Time: { Total: timeoutAfter / 1000 }}\n        }, timeoutAfter);\n      });\n      this.analysis = Promise.race([this.worker, this.timeout]);\n      // FIXME: halt webassembly worker thread on timeout\n\n      this.getFrontier = async function () {\n        return (await this.analysis).frontier;\n      };\n      this.getTraces = async function () {\n        return (await this.analysis).traces;\n      };\n    }\n  };\n}\nfunction _ruleString() {\n  return `\nstep(0..n).                                 % bounded time\nvalue(-1..24). \n\nseen(enter,0).\n% :- ending(X), not 1 <= { seen(X,T) : step(T) }.\n:- node(X), not hub(X), { seen(X,T) : step(T) } > 1.  % do not repeat yourself\n:- hub(X), seen(X,T), seen(X,T+1), step(T).           % do not sit on the hub\n\n:- goal(X), node(X), { seen(X,T) : step(T) } < 1.              % I need to see each goal once\n% 1 <= { seen(X,T) : step(T) } :- goal(X).            % I may *choose to* see each goal once\n:- poison(X), seen(X,T), node(X), step(T).            % I can't see poison\n\n:- goal(Y), class(Y), {seen(X,T) : abstracts(Y, X), step(T)} < 1.\n:- poison(Y), abstracts(Y, X), seen(X,T), step(T).\n\n% :- not seen(X,T), pin(X,T).                           % I need to see each pin\nseen(X,T) :- pin(X,T).\n% :- seen(X,T), seen(Y,T), X != Y, step(T).\n:- step(T), 2 { seen(X,T): node(X) }.\n\n% walk along the trace\n{ seen(Y,T) : available(Y,T) } = 1 :-\n  seen(X,T-1),\n  not T-1 == n.\navailable(Y,T) :-\n  step(T),\n  node(Y),\n  satisfied(Q, Op, V, T) : wants(Y, Q, Op, V).\n\n% enforce preconditions\never_wants(Q, Op, Thresh) :- wants(Y, Q, Op, Thresh).\nsatisfied(Q, eq, V, T) :- has(Q, V, T).\nsatisfied(Q, geq, Thresh, T) :- has(Q, V, T), V >= Thresh, ever_wants(Q, geq, Thresh).\nsatisfied(Q, leq, Thresh, T) :- has(Q, V, T), V <= Thresh, ever_wants(Q, leq, Thresh).\nsatisfied(Q, gt, Thresh, T) :- has(Q, V, T), V > Thresh, ever_wants(Q, gt, Thresh).\nsatisfied(Q, lt, Thresh, T) :- has(Q, V, T), V < Thresh, ever_wants(Q, lt, Thresh).\n\n% link(enter, Y) :- root(Y).                  % link every root to hub\n% link(X, Y) :- leaf(X), root(Y).\n\n% link(X, enter) :- leaf(X).\n% link(X, Y) :- parent(X,Y).                  % link every choice to parent\n\n% reaches(Q,V) :- has(Q,V,T).\nvisited(X,T) :- seen(X,T). % not hub(X).\n\n% apply postconditions\never_set(T, Q, Op, V) :- seen(X, T), sets(X, Q, Op, V).\nhas(Q,V,T+1) :- ever_set(T,Q,set,V), value(V).\nhas(Q,V,T+1) :- ever_set(T,Q,inc,Delta), has(Q,V-Delta,T), value(V), value(Delta).\nhas(Q,V,T+1) :- ever_set(T,Q,dec,Delta), has(Q,V+Delta,T), value(V), value(Delta).\n\nupdated(Q,T) :- ever_set(T,Q,_Op,_V).   % mark when the quality is touched\nhas(Q,V,T+1) :-                                % floodfill values until mark\n\thas(Q,V,T),\n  step(T),\n\tnot updated(Q,T).\n\n% #show time_1(Q,V): has(Q,V,1), V > 0.\n% #show has(Q,V,T): has(Q,V,T), V > 0.\n\n#show reaches(Q,V): has(Q,V,T), T == n, V != 0.\n#show visited/2.\n`;\n}\nfunction _preconditions(mungeOpsTree, nodesIn) {\n  return s => {\n    let munge = mungeOpsTree({\n      \"<=\": \"lte\",\n      \"<\": \"lt\",\n      \"=\": \"eq\",\n      \">=\": \"gte\",\n      \">\": \"gt\"\n    });\n    let ret = nodesIn(s, \"inclusive\").map(node => [...munge(node[\"view-if\"]), ...munge(node[\"choose-if\"])].map(v => [node[\"label\"], v])).flat().map(([k, v]) => `wants(${k}, ${v.join(\", \")}).`);\n    return ret;\n  };\n}\nfunction _postconditions(mungeOpsTree, nodesIn) {\n  return s => {\n    let munge = mungeOpsTree({\n      \"+=\": \"inc\",\n      \"-=\": \"dec\",\n      \"=\": \"set\"\n    });\n    let ret = nodesIn(s, \"inclusive\").map(node => munge(node[\"on-arrival\"]).map(v => [node[\"label\"], v])).flat().map(([k, v]) => `sets(${k}, ${v.join(\", \")}).`);\n    return ret;\n  };\n}\nfunction _combineOnArrival() {\n  return path => Object.fromEntries([\"=\", \"+=\", \"-=\"].map(op => {\n    return [op, path.reduce((acc, v) => {\n      if (!v[\"on-arrival\"]) return acc;\n      let res = {\n        ...v[\"on-arrival\"][op]\n      } || {}; // NOTE: we'd need a deep clone for object-valued qualities\n      let collisions = Object.keys(res).filter(k => acc[k]);\n      collisions.forEach(k => {\n        // apply both conditions\n        if ([\"+=\", \"-=\"].includes(op)) res[k] += acc[k];else res[k] = acc[k]; // last assignment takes precedence\n      });\n\n      return Object.assign(acc, res);\n    }, {})];\n  }).filter(([k, v]) => Object.keys(v).length > 0));\n}\nfunction _combineViewIf() {\n  return (path, prop = \"view-if\") => Object.fromEntries([\">\", \">=\", \"=\", \"<=\", \"<\"].map(op => {\n    return [op, path.reduce((acc, v) => {\n      if (!v[prop]) return acc;\n      let res = v[prop][op] || {};\n      let collisions = Object.keys(res).filter(k => acc[k]);\n      collisions.forEach(k => {\n        // take intersection of both conditions\n        if ([\">\", \">=\"].includes(op)) res[k] = Math.max(acc[k], res[k]);else if ([\"<\", \"<=\"].includes(op)) res[k] = Math.min(acc[k], res[k]);else res[k] = acc[k] == res[k] ? acc[k] : null;\n      });\n      return Object.assign(acc, res);\n      // FIXME: requirements downstream of assignment to the same key must be modified, if there is some collision\n    }, {})];\n  }).filter(([k, v]) => Object.keys(v).length > 0));\n}\nfunction _60(pathsByScene, scenes) {\n  return pathsByScene(scenes[0]);\n}\nfunction _pathsByScene(combineOnArrival, combineViewIf) {\n  return s => {\n    let ret = [[s]],\n      root = s;\n    // recursively generate paths, without repeating yourself\n    // TODO: allow intentional loops (e.g. dialogue) that are obviously self-limiting\n    //      (i.e. an exception for view-if[=] / on-arrival[+=] pairs)\n    let depth = 0;\n    while (ret.some(u => u[0][\"go-to\"] || u[0].choices.length > 0)) {\n      depth += 1;\n      if (depth > 40) throw Error(\"Infinite loop in scene: \" + s[\"title\"]);\n      ret = ret.map(u => {\n        return u[0].choices.length == 0 ? u[0][\"go-to\"] ? u[0][\"go-to\"].split(\"; \").map(l => \"@\" + l).map(v => [root[v], ...u]) : [u] : u[0].choices.filter(v => !u.map(seen => seen.label).includes(root[v].label)).map(v => [root[v], ...u]);\n      }).flat();\n    }\n\n    // generate view-if and on-arrival for each path\n    return ret.map((u, i) => {\n      let onArrival = combineOnArrival(u);\n      let viewIf = combineViewIf(u);\n      let chooseIf = combineViewIf(u, \"choose-if\");\n      // warn if assignments and requirements collide\n\n      let collisions = Object.values(viewIf).map(kv => Object.keys(kv)).filter(ks => Object.values(onArrival).map(kv => Object.keys(kv)).includes(ks));\n      if (collisions.length > 0) throw `Feature not implemented: ${collisions} occurs in both a precondition and a postcondition`;\n      let res = Object.keys(chooseIf).length > 0 ? Object.assign(u, {\n        \"choose-if\": chooseIf\n      }) : u;\n      return Object.assign(res, {\n        \"view-if\": viewIf,\n        \"on-arrival\": onArrival,\n        label: `v${i}_${s.label}`\n      });\n    });\n  };\n}\nfunction _scenesExpanded(scenes, pathsByScene) {\n  return scenes.map(pathsByScene);\n  // TODO: disambiguate 'epilogue' scenes 23 - 27\n}\n\nfunction _scenesIndex(scenesExpanded) {\n  return scenesExpanded.flat();\n}\nfunction _hand(scenesIndex) {\n  return scenesIndex.filter(u => u[0][\"max-choices\"]).map(u => u.label);\n}\nfunction _domainString(scenesIndex, hand, scenes, scenesExpanded, preconditions, postconditions) {\n  return `\nhub(enter). node(enter).\nnode(${scenesIndex.map(s => s.label).filter(l => !hand.includes(l)).join(\"; \")}).\nroot(${scenesIndex.map(s => s.label).join(\"; \")}).\nleaf(${scenesIndex.map(s => s.label).join(\"; \")}).\n\nclass(${scenes.map(s => s.label).join(\"; \")}).\n${scenesIndex.map(s => `abstracts(${s.label.split(\"_\").slice(1).join(\"_\")}, ${s.label}).`).join(\" \")}\n\n${scenesExpanded.flat().map(s => preconditions(s)).flat().join(\" \")}\n${scenesExpanded.flat().map(s => postconditions(s)).flat().join(\" \")}\n`;\n  /* `\n  hub(enter).\n  root(${scenes.map((s) => s.label).join(\"; \")}).\n  leaf(${scenes\n  .map((s) =>\n    leavesIn(s)\n      .filter((s) => s[0] == \"@\")\n      .map((k) => s[k].label)\n  )\n  .flat()\n  .join(\"; \")}).\n  parent(${scenes\n  .map((s) =>\n    linksIn(s)\n      .map((vw) => vw.join(\", \"))\n      .join(\"; \")\n  )\n  .filter((s) => s)\n  .join(\").\\n parent(\")}).\n  ${scenes\n  .map((s) => preconditions(s))\n  .flat()\n  .join(\"\\n\")}\n  ${scenes\n  .map((s) => postconditions(s))\n  .flat()\n  .join(\"\\n\")}\n  node(${nodes.join(\"; \")}).\n  ` */\n}\n\nfunction _66(md) {\n  return md`### ui helpers`;\n}\nfunction _pres(scenes, extract) {\n  return scenes.reduce((acc, scene) => {\n    acc.push(extract(scene[\"view-if\"]));\n    return acc;\n  }, []);\n}\nfunction _posts(scenes, extract) {\n  return scenes.reduce((acc, scene) => {\n    acc.push(extract(scene[\"on-arrival\"]));\n    return acc;\n  }, []);\n}\nfunction _variables(pres, posts) {\n  return new Set([...pres.flat(), ...posts.flat()]);\n}\nfunction _makeToggle(Inputs) {\n  return (variable, prompt, value = false) => Object.assign(Inputs.toggle({\n    label: `${prompt} ${variable}`,\n    value\n  }), {\n    variable\n  });\n}\nfunction _71(md) {\n  return md`### ast helpers`;\n}\nfunction _filterEffectsBuffer() {\n  return [];\n}\nfunction _conditionsByVar() {\n  return v => scene => {\n    let src = scene[\"view-if\"] || {};\n    return Object.entries(src).reduce((acc, [op, kv]) => {\n      if (Object.keys(kv).includes(v)) acc.push({\n        value: kv[v],\n        op\n      });\n      return acc;\n    }, []);\n  };\n}\nfunction _effectsByVar() {\n  return v => scene => {\n    let src = scene[\"on-arrival\"] || {};\n    return Object.entries(src).reduce((acc, [op, kv]) => {\n      if (Object.keys(kv).includes(v)) acc.push({\n        value: kv[v],\n        op\n      });\n      return acc;\n    }, []);\n  };\n}\nfunction _extract() {\n  return ops => {\n    if (!ops) return [];\n    let res = Object.values(ops);\n    return res.map(u => Object.keys(u)).flat();\n  };\n}\nfunction _76(md) {\n  return md`### requirements`;\n}\nfunction _ast(FileAttachment) {\n  return FileAttachment(\"bee-scenes-ast@2.json\").json();\n}\nasync function _run(require) {\n  const clingo = await require(\"clingo-wasm@0.0.14\");\n  await clingo.init(\"https://cdn.jsdelivr.net/npm/clingo-wasm@0.0.14/dist/clingo.wasm\");\n  return clingo.run;\n}\nfunction _81(md) {\n  return md`### scratch`;\n}\nfunction _pathsFrom(scenes) {\n  return node => {\n    function follow(node) {\n      // fixme: ground\n\n      let choices = node[\"title\"] ? Object.keys(node[node[\"title\"]]) : Object.keys(node).filter(k => k[0] == \"@\");\n      if (!choices) {\n        let goto = Object.entries(node).find(([k, v]) => k == \"go-to\");\n        if (goto !== undefined) {\n          return follow(scenes[goto[1].split(\"; \")]);\n        }\n      }\n      return follow(choices);\n    }\n    return follow(node);\n  };\n}\nfunction _paths(pathsFrom) {\n  return scene => {\n    let ret = pathsFrom(scene);\n    // FIXME: follow go-to. accumulate view-if and on-arrival.\n\n    ret = ret.reduce((acc, [key, choice]) => {\n      acc.push(...pathsFrom(choice).map(u => [key, ...u]));\n      return acc;\n    }, []);\n\n    // FIXME: to arbitrary depth\n    return ret;\n  };\n}\nfunction define(runtime, observer) {\n  const main = runtime.module();\n  function toString() {\n    return this.url;\n  }\n  const fileAttachments = new Map([[\"bee-scenes-ast@2.json\", \"./dist/3d213cdc68443ea49186.json\"]\n  // {url: new URL(\"../files/d40ed751d78762152ac802170df5e29559e7bc94ee5217c15098b8394504c05d9178a1daa9dd106136399f92fbf5ff72736e04f64284c523a09689fdc5eb4a71.json\", ({ url: getAbsoluteUrl('src/8d0508ea75589ad1@4544.js') }).url), mimeType: \"application/json\", toString}\n  ]);\n\n  main.builtin(\"FileAttachment\", runtime.fileAttachments(name => fileAttachments.get(name)));\n  main.variable(observer()).define(\"legendSwatches\", [\"Swatches\", \"colorByTag\"], _legendSwatches);\n  main.variable(observer()).define([\"html\", \"legendSwatches\", \"hoverPredicate\"], _3);\n  main.variable(observer()).define(\"viewof peek\", [\"html\", \"width\", \"d3\", \"xScale\", \"steps\", \"horizon\", \"Event\", \"mutable xSelection\", \"visibilityChart\"], _peek);\n  main.variable(observer()).define(\"peek\", [\"Generators\", \"viewof peek\"], (G, _) => G.input(_));\n  main.variable(observer()).define(\"visibilityChart\", [\"legend\", \"html\", \"d3\", \"colorByTag\", \"legendTags\", \"mutable requiredNodes\", \"mutable forbiddenNodes\", \"stepFrequencies\", \"mutable xSelection\", \"mutable pinnedNodes\", \"mutable forcedNodes\", \"steps\", \"mutable hoverPredicate\"], _visibilityChart);\n  main.variable(observer()).define(\"controlBox\", [\"html\", \"viewof horizon\", \"viewof timeout\", \"viewof doQuery\"], _controlBox);\n  main.variable(observer()).define(\"inspectorBox\", [\"html\", \"makeCard\", \"scene\", \"sceneVersion\", \"makeStateChart\"], _inspectorBox);\n  main.variable(observer(\"sceneVersion\")).define([\"sceneVersion\"], _9);\n  main.variable(observer(\"qPreview\")).define(\"qPreview\", [\"DendryQuery\", \"requiredNodes\", \"forbiddenNodes\", \"pinnedNodes\", \"forcedNodes\", \"viewof horizon\", \"viewof timeout\"], _qPreview);\n  main.variable(observer()).define(\"queryPreview\", [\"qPreview\"], _queryPreview);\n  main.define(\"initial pinnedNodes\", _pinnedNodes);\n  main.variable(observer(\"mutable pinnedNodes\")).define(\"mutable pinnedNodes\", [\"Mutable\", \"initial pinnedNodes\"], (M, _) => new M(_));\n  main.variable(observer(\"pinnedNodes\")).define(\"pinnedNodes\", [\"mutable pinnedNodes\"], _ => _.generator);\n  main.define(\"initial forcedNodes\", _forcedNodes);\n  main.variable(observer(\"mutable forcedNodes\")).define(\"mutable forcedNodes\", [\"Mutable\", \"initial forcedNodes\"], (M, _) => new M(_));\n  main.variable(observer(\"forcedNodes\")).define(\"forcedNodes\", [\"mutable forcedNodes\"], _ => _.generator);\n  main.define(\"initial requiredNodes\", _requiredNodes);\n  main.variable(observer(\"mutable requiredNodes\")).define(\"mutable requiredNodes\", [\"Mutable\", \"initial requiredNodes\"], (M, _) => new M(_));\n  main.variable(observer(\"requiredNodes\")).define(\"requiredNodes\", [\"mutable requiredNodes\"], _ => _.generator);\n  main.define(\"initial forbiddenNodes\", _forbiddenNodes);\n  main.variable(observer(\"mutable forbiddenNodes\")).define(\"mutable forbiddenNodes\", [\"Mutable\", \"initial forbiddenNodes\"], (M, _) => new M(_));\n  main.variable(observer(\"forbiddenNodes\")).define(\"forbiddenNodes\", [\"mutable forbiddenNodes\"], _ => _.generator);\n  main.variable(observer(\"q\")).define(\"q\", [\"doQuery\", \"DendryQuery\", \"mutable requiredNodes\", \"mutable forbiddenNodes\", \"mutable pinnedNodes\", \"mutable forcedNodes\", \"viewof horizon\", \"viewof timeout\"], _q);\n  main.variable(observer()).define(\"viewof browseTag\", [\"Inputs\", \"scenes\"], _browseTag);\n  main.variable(observer(\"browseTag\")).define(\"browseTag\", [\"Generators\", \"viewof browseTag\"], (G, _) => G.input(_));\n  main.variable(observer()).define([\"md\", \"scenes\", \"browseTag\", \"d3\"], _18);\n  main.variable(observer()).define([\"md\"], _1);\n  main.variable(observer(\"xScale\")).define(\"xScale\", [\"d3\", \"horizon\", \"width\"], _xScale);\n  main.variable(observer(\"viewof horizon\")).define(\"viewof horizon\", [\"Inputs\"], _horizon);\n  main.variable(observer(\"horizon\")).define(\"horizon\", [\"Generators\", \"viewof horizon\"], (G, _) => G.input(_));\n  main.variable(observer(\"viewof timeout\")).define(\"viewof timeout\", [\"Inputs\"], _timeout);\n  main.variable(observer(\"timeout\")).define(\"timeout\", [\"Generators\", \"viewof timeout\"], (G, _) => G.input(_));\n  main.variable(observer(\"viewof doQuery\")).define(\"viewof doQuery\", [\"html\"], _doQuery);\n  main.variable(observer(\"doQuery\")).define(\"doQuery\", [\"Generators\", \"viewof doQuery\"], (G, _) => G.input(_));\n  main.define(\"initial debug\", _debug);\n  main.variable(observer(\"mutable debug\")).define(\"mutable debug\", [\"Mutable\", \"initial debug\"], (M, _) => new M(_));\n  main.variable(observer(\"debug\")).define(\"debug\", [\"mutable debug\"], _ => _.generator);\n  main.variable(observer(\"makeStateChart\")).define(\"makeStateChart\", [\"hasSeen\", \"hoverPredicate\", \"mungePredicate\", \"html\", \"d3\", \"mutable traceBuilder\", \"viewof horizon\"], _makeStateChart);\n  main.define(\"initial traceBuilder\", _traceBuilder);\n  main.variable(observer(\"mutable traceBuilder\")).define(\"mutable traceBuilder\", [\"Mutable\", \"initial traceBuilder\"], (M, _) => new M(_));\n  main.variable(observer(\"traceBuilder\")).define(\"traceBuilder\", [\"mutable traceBuilder\"], _ => _.generator);\n  main.define(\"initial hoverPredicate\", _hoverPredicate);\n  main.variable(observer(\"mutable hoverPredicate\")).define(\"mutable hoverPredicate\", [\"Mutable\", \"initial hoverPredicate\"], (M, _) => new M(_));\n  main.variable(observer(\"hoverPredicate\")).define(\"hoverPredicate\", [\"mutable hoverPredicate\"], _ => _.generator);\n  main.variable(observer(\"viewof filterIndex\")).define(\"viewof filterIndex\", [\"Inputs\", \"visibility\"], _filterIndex);\n  main.variable(observer(\"filterIndex\")).define(\"filterIndex\", [\"Generators\", \"viewof filterIndex\"], (G, _) => G.input(_));\n  main.define(\"initial xSelection\", [\"xScale\"], _xSelection);\n  main.variable(observer(\"mutable xSelection\")).define(\"mutable xSelection\", [\"Mutable\", \"initial xSelection\"], (M, _) => new M(_));\n  main.variable(observer(\"xSelection\")).define(\"xSelection\", [\"mutable xSelection\"], _ => _.generator);\n  main.variable(observer(\"getLabels\")).define(\"getLabels\", _getLabels);\n  // main.variable(observer()).define([\"md\"], _30);\n  main.variable(observer(\"scenes\")).define(\"scenes\", [\"ast\", \"getLabels\"], _scenes);\n  main.variable(observer(\"egress\")).define(\"egress\", _egress);\n  main.variable(observer(\"labelsIn\")).define(\"labelsIn\", _labelsIn);\n  main.variable(observer(\"nodesIn\")).define(\"nodesIn\", _nodesIn);\n  main.variable(observer(\"nodes\")).define(\"nodes\", [\"scenes\", \"labelsIn\"], _nodes);\n  main.variable(observer(\"linksIn\")).define(\"linksIn\", [\"egress\"], _linksIn);\n  main.variable(observer(\"leavesIn\")).define(\"leavesIn\", [\"egress\"], _leavesIn);\n  main.variable(observer(\"mungeOpsTree\")).define(\"mungeOpsTree\", _mungeOpsTree);\n  main.variable(observer(\"sceneVersion\")).define(\"sceneVersion\", [\"scenesExpanded\", \"hoverPredicate\"], _sceneVersion);\n  main.variable(observer(\"scene\")).define(\"scene\", [\"scenes\", \"labelsIn\", \"hoverPredicate\"], _scene);\n  main.variable(observer(\"makeCard\")).define(\"makeCard\", [\"html\", \"d3\", \"steps\", \"scenesIndex\", \"stepFrequencies\", \"commonVariables\"], _makeCard);\n  main.variable(observer(\"commonVariables\")).define(\"commonVariables\", [\"variables\", \"pres\", \"scenes\"], _commonVariables);\n  main.variable(observer(\"earliestSeen\")).define(\"earliestSeen\", [\"scenesIndex\", \"steps\"], _earliestSeen);\n  main.variable(observer(\"legend\")).define(\"legend\", [\"steps\", \"scenesIndex\", \"earliestSeen\"], _legend);\n  main.variable(observer(\"colorByTag\")).define(\"colorByTag\", [\"d3\", \"scenes\"], _colorByTag);\n  main.variable(observer(\"legendTags\")).define(\"legendTags\", [\"scenesIndex\", \"legend\", \"scenes\"], _legendTags);\n  main.variable(observer(\"visibility\")).define(\"visibility\", [\"q\"], _visibility);\n  main.variable(observer(\"steps\")).define(\"steps\", [\"visibility\", \"filterIndex\", \"mungePredicate\"], _steps);\n  main.variable(observer(\"stepFrequencies\")).define(\"stepFrequencies\", [\"steps\", \"hasSeen\"], _stepFrequencies);\n  main.variable(observer(\"lastSceneCandidates\")).define(\"lastSceneCandidates\", [\"steps\", \"horizon\"], _lastSceneCandidates);\n  main.variable(observer(\"hasSeen\")).define(\"hasSeen\", [\"q\"], _hasSeen);\n  main.variable(observer(\"mungePredicate\")).define(\"mungePredicate\", _mungePredicate);\n  main.variable(observer(\"DendryQuery\")).define(\"DendryQuery\", [\"ruleString\", \"domainString\", \"run\"], _DendryQuery);\n  main.variable(observer(\"ruleString\")).define(\"ruleString\", _ruleString);\n  main.variable(observer(\"preconditions\")).define(\"preconditions\", [\"mungeOpsTree\", \"nodesIn\"], _preconditions);\n  main.variable(observer(\"postconditions\")).define(\"postconditions\", [\"mungeOpsTree\", \"nodesIn\"], _postconditions);\n  main.variable(observer(\"combineOnArrival\")).define(\"combineOnArrival\", _combineOnArrival);\n  main.variable(observer(\"combineViewIf\")).define(\"combineViewIf\", _combineViewIf);\n  // main.variable(observer()).define([\"pathsByScene\",\"scenes\"], _60);\n  main.variable(observer(\"pathsByScene\")).define(\"pathsByScene\", [\"combineOnArrival\", \"combineViewIf\"], _pathsByScene);\n  main.variable(observer(\"scenesExpanded\")).define(\"scenesExpanded\", [\"scenes\", \"pathsByScene\"], _scenesExpanded);\n  main.variable(observer(\"scenesIndex\")).define(\"scenesIndex\", [\"scenesExpanded\"], _scenesIndex);\n  main.variable(observer(\"hand\")).define(\"hand\", [\"scenesIndex\"], _hand);\n  main.variable(observer(\"domainString\")).define(\"domainString\", [\"scenesIndex\", \"hand\", \"scenes\", \"scenesExpanded\", \"preconditions\", \"postconditions\"], _domainString);\n  // main.variable(observer()).define([\"md\"], _66);\n  main.variable(observer(\"pres\")).define(\"pres\", [\"scenes\", \"extract\"], _pres);\n  main.variable(observer(\"posts\")).define(\"posts\", [\"scenes\", \"extract\"], _posts);\n  main.variable(observer(\"variables\")).define(\"variables\", [\"pres\", \"posts\"], _variables);\n  main.variable(observer(\"makeToggle\")).define(\"makeToggle\", [\"Inputs\"], _makeToggle);\n  // main.variable(observer()).define([\"md\"], _71);\n  main.define(\"initial filterEffectsBuffer\", _filterEffectsBuffer);\n  main.variable(observer(\"mutable filterEffectsBuffer\")).define(\"mutable filterEffectsBuffer\", [\"Mutable\", \"initial filterEffectsBuffer\"], (M, _) => new M(_));\n  main.variable(observer(\"filterEffectsBuffer\")).define(\"filterEffectsBuffer\", [\"mutable filterEffectsBuffer\"], _ => _.generator);\n  main.variable(observer(\"conditionsByVar\")).define(\"conditionsByVar\", _conditionsByVar);\n  main.variable(observer(\"effectsByVar\")).define(\"effectsByVar\", _effectsByVar);\n  main.variable(observer(\"extract\")).define(\"extract\", _extract);\n  // main.variable(observer()).define([\"md\"], _76);\n  main.variable(observer(\"ast\")).define(\"ast\", [\"FileAttachment\"], _ast);\n  main.variable(observer(\"run\")).define(\"run\", [\"require\"], _run);\n  const child1 = runtime.module(_a33468b95d0b15b0_808_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n  main.import(\"Swatches\", child1);\n  // main.variable(observer()).define([\"md\"], _81);\n  main.variable(observer(\"pathsFrom\")).define(\"pathsFrom\", [\"scenes\"], _pathsFrom);\n  main.variable(observer(\"paths\")).define(\"paths\", [\"pathsFrom\"], _paths);\n  return main;\n}\n\n//# sourceURL=webpack://@jazztap/dendryscope-demo/./src/8d0508ea75589ad1@4544.js?");

/***/ }),

/***/ "./src/a33468b95d0b15b0@808.js":
/*!*************************************!*\
  !*** ./src/a33468b95d0b15b0@808.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ define)\n/* harmony export */ });\nfunction _1(md) {\n  return md`# Color Legend\n\nA simple legend for a [color scale](/@d3/color-schemes). Supports [continuous](/@d3/continuous-scales), [sequential](/@d3/sequential-scales), [diverging](/@d3/diverging-scales), [quantize, quantile, threshold](/@d3/quantile-quantize-and-threshold-scales) and [ordinal](/@d3/d3-scaleordinal) scales. To use:\n\n~~~js\nimport {Legend, Swatches} from \"@d3/color-legend\"\n~~~\n\nThen call the legend function as shown below. (For ordinal scales, also consider the swatches function.)`;\n}\nfunction _2(Legend, d3) {\n  return Legend(d3.scaleSequential([0, 100], d3.interpolateViridis), {\n    title: \"Temperature (Â°F)\"\n  });\n}\nfunction _3(Legend, d3) {\n  return Legend(d3.scaleSequentialSqrt([0, 1], d3.interpolateTurbo), {\n    title: \"Speed (kts)\"\n  });\n}\nfunction _4(Legend, d3) {\n  return Legend(d3.scaleDiverging([-0.1, 0, 0.1], d3.interpolatePiYG), {\n    title: \"Daily change\",\n    tickFormat: \"+%\"\n  });\n}\nfunction _5(Legend, d3) {\n  return Legend(d3.scaleDivergingSqrt([-0.1, 0, 0.1], d3.interpolateRdBu), {\n    title: \"Daily change\",\n    tickFormat: \"+%\"\n  });\n}\nfunction _6(Legend, d3) {\n  return Legend(d3.scaleSequentialLog([1, 100], d3.interpolateBlues), {\n    title: \"Energy (joules)\",\n    ticks: 10\n  });\n}\nfunction _7(Legend, d3) {\n  return Legend(d3.scaleSequentialQuantile(d3.range(100).map(() => Math.random() ** 2), d3.interpolateBlues), {\n    title: \"Quantile\",\n    tickFormat: \".2f\"\n  });\n}\nfunction _8(Legend, d3) {\n  return Legend(d3.scaleSqrt([-100, 0, 100], [\"blue\", \"white\", \"red\"]), {\n    title: \"Temperature (Â°C)\"\n  });\n}\nfunction _9(Legend, d3) {\n  return Legend(d3.scaleQuantize([1, 10], d3.schemePurples[9]), {\n    title: \"Unemployment rate (%)\"\n  });\n}\nfunction _10(Legend, d3) {\n  return Legend(d3.scaleQuantile(d3.range(1000).map(d3.randomNormal(100, 20)), d3.schemeSpectral[9]), {\n    title: \"Height (cm)\",\n    tickFormat: \".0f\"\n  });\n}\nfunction _11(Legend, d3) {\n  return Legend(d3.scaleThreshold([2.5, 3.1, 3.5, 3.9, 6, 7, 8, 9.5], d3.schemeRdBu[9]), {\n    title: \"Unemployment rate (%)\",\n    tickSize: 0\n  });\n}\nfunction _12(Legend, d3) {\n  return Legend(d3.scaleOrdinal([\"<10\", \"10-19\", \"20-29\", \"30-39\", \"40-49\", \"50-59\", \"60-69\", \"70-79\", \"â‰¥80\"], d3.schemeSpectral[10]), {\n    title: \"Age (years)\",\n    tickSize: 0\n  });\n}\nfunction _13(md) {\n  return md`But wait, thereâ€™s more!\n\nHow about swatches for ordinal color scales? Both variable-width swatches and [column layout](https://developer.mozilla.org/en-US/docs/Web/CSS/columns) are supported.`;\n}\nfunction _14(Swatches, d3) {\n  return Swatches(d3.scaleOrdinal([\"blueberries\", \"oranges\", \"apples\"], d3.schemeCategory10));\n}\nfunction _15(Swatches, d3) {\n  return Swatches(d3.scaleOrdinal([\"Wholesale and Retail Trade\", \"Manufacturing\", \"Leisure and hospitality\", \"Business services\", \"Construction\", \"Education and Health\", \"Government\", \"Finance\", \"Self-employed\", \"Other\"], d3.schemeTableau10), {\n    columns: \"180px\"\n  });\n}\nfunction _16(md) {\n  return md`---\n\n## Implementation`;\n}\nfunction _Legend(d3) {\n  return function Legend(color, {\n    title,\n    tickSize = 6,\n    width = 320,\n    height = 44 + tickSize,\n    marginTop = 18,\n    marginRight = 0,\n    marginBottom = 16 + tickSize,\n    marginLeft = 0,\n    ticks = width / 64,\n    tickFormat,\n    tickValues\n  } = {}) {\n    function ramp(color, n = 256) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = n;\n      canvas.height = 1;\n      const context = canvas.getContext(\"2d\");\n      for (let i = 0; i < n; ++i) {\n        context.fillStyle = color(i / (n - 1));\n        context.fillRect(i, 0, 1, 1);\n      }\n      return canvas;\n    }\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", [0, 0, width, height]).style(\"overflow\", \"visible\").style(\"display\", \"block\");\n    let tickAdjust = g => g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n    let x;\n\n    // Continuous\n    if (color.interpolate) {\n      const n = Math.min(color.domain().length, color.range().length);\n      x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n      svg.append(\"image\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginLeft - marginRight).attr(\"height\", height - marginTop - marginBottom).attr(\"preserveAspectRatio\", \"none\").attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n    }\n\n    // Sequential\n    else if (color.interpolator) {\n      x = Object.assign(color.copy().interpolator(d3.interpolateRound(marginLeft, width - marginRight)), {\n        range() {\n          return [marginLeft, width - marginRight];\n        }\n      });\n      svg.append(\"image\").attr(\"x\", marginLeft).attr(\"y\", marginTop).attr(\"width\", width - marginLeft - marginRight).attr(\"height\", height - marginTop - marginBottom).attr(\"preserveAspectRatio\", \"none\").attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n      // scaleSequentialQuantile doesnâ€™t implement ticks or tickFormat.\n      if (!x.ticks) {\n        if (tickValues === undefined) {\n          const n = Math.round(ticks + 1);\n          tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));\n        }\n        if (typeof tickFormat !== \"function\") {\n          tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n        }\n      }\n    }\n\n    // Threshold\n    else if (color.invertExtent) {\n      const thresholds = color.thresholds ? color.thresholds() // scaleQuantize\n      : color.quantiles ? color.quantiles() // scaleQuantile\n      : color.domain(); // scaleThreshold\n\n      const thresholdFormat = tickFormat === undefined ? d => d : typeof tickFormat === \"string\" ? d3.format(tickFormat) : tickFormat;\n      x = d3.scaleLinear().domain([-1, color.range().length - 1]).rangeRound([marginLeft, width - marginRight]);\n      svg.append(\"g\").selectAll(\"rect\").data(color.range()).join(\"rect\").attr(\"x\", (d, i) => x(i - 1)).attr(\"y\", marginTop).attr(\"width\", (d, i) => x(i) - x(i - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", d => d);\n      tickValues = d3.range(thresholds.length);\n      tickFormat = i => thresholdFormat(thresholds[i], i);\n    }\n\n    // Ordinal\n    else {\n      x = d3.scaleBand().domain(color.domain()).rangeRound([marginLeft, width - marginRight]);\n      svg.append(\"g\").selectAll(\"rect\").data(color.domain()).join(\"rect\").attr(\"x\", x).attr(\"y\", marginTop).attr(\"width\", Math.max(0, x.bandwidth() - 1)).attr(\"height\", height - marginTop - marginBottom).attr(\"fill\", color);\n      tickAdjust = () => {};\n    }\n    svg.append(\"g\").attr(\"transform\", `translate(0,${height - marginBottom})`).call(d3.axisBottom(x).ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined).tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined).tickSize(tickSize).tickValues(tickValues)).call(tickAdjust).call(g => g.select(\".domain\").remove()).call(g => g.append(\"text\").attr(\"x\", marginLeft).attr(\"y\", marginTop + marginBottom - height - 6).attr(\"fill\", \"currentColor\").attr(\"text-anchor\", \"start\").attr(\"font-weight\", \"bold\").attr(\"class\", \"title\").text(title));\n    return svg.node();\n  };\n}\nfunction _legend(Legend) {\n  return function legend({\n    color,\n    ...options\n  }) {\n    return Legend(color, options);\n  };\n}\nfunction _Swatches(d3, htl) {\n  return function Swatches(color, {\n    columns = null,\n    format,\n    unknown: formatUnknown,\n    swatchSize = 15,\n    swatchWidth = swatchSize,\n    swatchHeight = swatchSize,\n    marginLeft = 0\n  } = {}) {\n    const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n    const unknown = formatUnknown == null ? undefined : color.unknown();\n    const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n    const domain = color.domain().concat(unknowns);\n    if (format === undefined) format = x => x === unknown ? formatUnknown : x;\n    function entity(character) {\n      return `&#${character.charCodeAt(0).toString()};`;\n    }\n    if (columns !== null) return htl.html`<div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 10px sans-serif;\">\n  <style>\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  </style>\n  <div style=${{\n      width: \"100%\",\n      columns\n    }}>${domain.map(value => {\n      const label = `${format(value)}`;\n      return htl.html`<div class=${id}-item>\n      <div class=${id}-swatch style=${{\n        background: color(value)\n      }}></div>\n      <div class=${id}-label title=${label}>${label}</div>\n    </div>`;\n    })}\n  </div>\n</div>`;\n    return htl.html`<div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 10px sans-serif;\">\n  <style>\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  </style>\n  <div>${domain.map(value => htl.html`<span class=\"${id}\" style=\"--color: ${color(value)}\">${format(value)}</span>`)}</div>`;\n  };\n}\nfunction _swatches(Swatches) {\n  return function swatches({\n    color,\n    ...options\n  }) {\n    return Swatches(color, options);\n  };\n}\nfunction define(runtime, observer) {\n  const main = runtime.module();\n  main.variable(observer()).define([\"md\"], _1);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _2);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _3);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _4);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _5);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _6);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _7);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _8);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _9);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _10);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _11);\n  main.variable(observer()).define([\"Legend\", \"d3\"], _12);\n  main.variable(observer()).define([\"md\"], _13);\n  main.variable(observer()).define([\"Swatches\", \"d3\"], _14);\n  main.variable(observer()).define([\"Swatches\", \"d3\"], _15);\n  main.variable(observer()).define([\"md\"], _16);\n  main.variable(observer(\"Legend\")).define(\"Legend\", [\"d3\"], _Legend);\n  main.variable(observer(\"legend\")).define(\"legend\", [\"Legend\"], _legend);\n  main.variable(observer(\"Swatches\")).define(\"Swatches\", [\"d3\", \"htl\"], _Swatches);\n  main.variable(observer(\"swatches\")).define(\"swatches\", [\"Swatches\"], _swatches);\n  return main;\n}\n\n//# sourceURL=webpack://@jazztap/dendryscope-demo/./src/a33468b95d0b15b0@808.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _8d0508ea75589ad1_4544_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./8d0508ea75589ad1@4544.js */ \"./src/8d0508ea75589ad1@4544.js\");\n/* harmony import */ var _runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./runtime.js */ \"./src/runtime.js\");\n\n\nconst runtime = new _runtime_js__WEBPACK_IMPORTED_MODULE_1__.Runtime();\nconst main = runtime.module(_8d0508ea75589ad1_4544_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], name => !name ? _runtime_js__WEBPACK_IMPORTED_MODULE_1__.Inspector.into(document.body)(name) : {});\n\n//# sourceURL=webpack://@jazztap/dendryscope-demo/./src/index.js?");

/***/ }),

/***/ "./src/runtime.js":
/*!************************!*\
  !*** ./src/runtime.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Inspector: () => (/* binding */ Inspector),\n/* harmony export */   Library: () => (/* binding */ Library),\n/* harmony export */   Runtime: () => (/* binding */ Runtime),\n/* harmony export */   RuntimeError: () => (/* binding */ RuntimeError)\n/* harmony export */ });\n// @observablehq/runtime v5.9.2 Copyright 2023 Observable, Inc.\nfunction e(e, t, n) {\n  n = n || {};\n  var r = e.ownerDocument,\n    a = r.defaultView.CustomEvent;\n  \"function\" == typeof a ? a = new a(t, {\n    detail: n\n  }) : ((a = r.createEvent(\"Event\")).initEvent(t, !1, !1), a.detail = n), e.dispatchEvent(a);\n}\nfunction t(e) {\n  return Array.isArray(e) || e instanceof Int8Array || e instanceof Int16Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Uint16Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array;\n}\nfunction n(e) {\n  return e === (0 | e) + \"\";\n}\nfunction r(e) {\n  const t = document.createElement(\"span\");\n  return t.className = \"observablehq--cellname\", t.textContent = `${e} = `, t;\n}\nconst a = Symbol.prototype.toString;\nfunction o(e) {\n  return a.call(e);\n}\nconst {\n    getOwnPropertySymbols: i,\n    prototype: {\n      hasOwnProperty: s\n    }\n  } = Object,\n  {\n    toStringTag: c\n  } = Symbol,\n  l = {},\n  u = i;\nfunction f(e, t) {\n  return s.call(e, t);\n}\nfunction d(e) {\n  return e[c] || e.constructor && e.constructor.name || \"Object\";\n}\nfunction p(e, t) {\n  try {\n    const n = e[t];\n    return n && n.constructor, n;\n  } catch (e) {\n    return l;\n  }\n}\nconst m = [{\n  symbol: \"@@__IMMUTABLE_INDEXED__@@\",\n  name: \"Indexed\",\n  modifier: !0\n}, {\n  symbol: \"@@__IMMUTABLE_KEYED__@@\",\n  name: \"Keyed\",\n  modifier: !0\n}, {\n  symbol: \"@@__IMMUTABLE_LIST__@@\",\n  name: \"List\",\n  arrayish: !0\n}, {\n  symbol: \"@@__IMMUTABLE_MAP__@@\",\n  name: \"Map\"\n}, {\n  symbol: \"@@__IMMUTABLE_ORDERED__@@\",\n  name: \"Ordered\",\n  modifier: !0,\n  prefix: !0\n}, {\n  symbol: \"@@__IMMUTABLE_RECORD__@@\",\n  name: \"Record\"\n}, {\n  symbol: \"@@__IMMUTABLE_SET__@@\",\n  name: \"Set\",\n  arrayish: !0,\n  setish: !0\n}, {\n  symbol: \"@@__IMMUTABLE_STACK__@@\",\n  name: \"Stack\",\n  arrayish: !0\n}];\nfunction h(e) {\n  try {\n    let t = m.filter(({\n      symbol: t\n    }) => !0 === e[t]);\n    if (!t.length) return;\n    const n = t.find(e => !e.modifier),\n      r = \"Map\" === n.name && t.find(e => e.modifier && e.prefix),\n      a = t.some(e => e.arrayish),\n      o = t.some(e => e.setish);\n    return {\n      name: `${r ? r.name : \"\"}${n.name}`,\n      symbols: t,\n      arrayish: a && !o,\n      setish: o\n    };\n  } catch (e) {\n    return null;\n  }\n}\nconst {\n    getPrototypeOf: b,\n    getOwnPropertyDescriptors: w\n  } = Object,\n  v = b({});\nfunction y(n, a, o, i) {\n  let s,\n    c,\n    l,\n    u,\n    f = t(n);\n  n instanceof Map ? n instanceof n.constructor ? (s = `Map(${n.size})`, c = _) : (s = \"Map()\", c = T) : n instanceof Set ? n instanceof n.constructor ? (s = `Set(${n.size})`, c = g) : (s = \"Set()\", c = T) : f ? (s = `${n.constructor.name}(${n.length})`, c = C) : (u = h(n)) ? (s = `Immutable.${u.name}${\"Record\" === u.name ? \"\" : `(${n.size})`}`, f = u.arrayish, c = u.arrayish ? N : u.setish ? E : A) : i ? (s = d(n), c = x) : (s = d(n), c = T);\n  const p = document.createElement(\"span\");\n  p.className = \"observablehq--expanded\", o && p.appendChild(r(o));\n  const m = p.appendChild(document.createElement(\"a\"));\n  m.innerHTML = \"<svg width=8 height=8 class='observablehq--caret'>\\n    <path d='M4 7L0 1h8z' fill='currentColor' />\\n  </svg>\", m.appendChild(document.createTextNode(`${s}${f ? \" [\" : \" {\"}`)), m.addEventListener(\"mouseup\", function (e) {\n    e.stopPropagation(), ie(p, L(n, null, o, i));\n  }), c = c(n);\n  for (let e = 0; !(l = c.next()).done && e < 20; ++e) p.appendChild(l.value);\n  if (!l.done) {\n    const t = p.appendChild(document.createElement(\"a\"));\n    t.className = \"observablehq--field\", t.style.display = \"block\", t.appendChild(document.createTextNode(\"  â€¦ more\")), t.addEventListener(\"mouseup\", function (t) {\n      t.stopPropagation(), p.insertBefore(l.value, p.lastChild.previousSibling);\n      for (let e = 0; !(l = c.next()).done && e < 19; ++e) p.insertBefore(l.value, p.lastChild.previousSibling);\n      l.done && p.removeChild(p.lastChild.previousSibling), e(p, \"load\");\n    });\n  }\n  return p.appendChild(document.createTextNode(f ? \"]\" : \"}\")), p;\n}\nfunction* _(e) {\n  for (const [t, n] of e) yield S(t, n);\n  yield* T(e);\n}\nfunction* g(e) {\n  for (const t of e) yield q(t);\n  yield* T(e);\n}\nfunction* E(e) {\n  for (const t of e) yield q(t);\n}\nfunction* C(e) {\n  for (let t = 0, n = e.length; t < n; ++t) t in e && (yield $(t, p(e, t), \"observablehq--index\"));\n  for (const t in e) !n(t) && f(e, t) && (yield $(t, p(e, t), \"observablehq--key\"));\n  for (const t of u(e)) yield $(o(t), p(e, t), \"observablehq--symbol\");\n}\nfunction* N(e) {\n  let t = 0;\n  for (const n = e.size; t < n; ++t) yield $(t, e.get(t), !0);\n}\nfunction* x(e) {\n  for (const t in w(e)) yield $(t, p(e, t), \"observablehq--key\");\n  for (const t of u(e)) yield $(o(t), p(e, t), \"observablehq--symbol\");\n  const t = b(e);\n  t && t !== v && (yield j(t));\n}\nfunction* T(e) {\n  for (const t in e) f(e, t) && (yield $(t, p(e, t), \"observablehq--key\"));\n  for (const t of u(e)) yield $(o(t), p(e, t), \"observablehq--symbol\");\n  const t = b(e);\n  t && t !== v && (yield j(t));\n}\nfunction* A(e) {\n  for (const [t, n] of e) yield $(t, n, \"observablehq--key\");\n}\nfunction j(e) {\n  const t = document.createElement(\"div\"),\n    n = t.appendChild(document.createElement(\"span\"));\n  return t.className = \"observablehq--field\", n.className = \"observablehq--prototype-key\", n.textContent = \"  <prototype>\", t.appendChild(document.createTextNode(\": \")), t.appendChild(oe(e, void 0, void 0, void 0, !0)), t;\n}\nfunction $(e, t, n) {\n  const r = document.createElement(\"div\"),\n    a = r.appendChild(document.createElement(\"span\"));\n  return r.className = \"observablehq--field\", a.className = n, a.textContent = `  ${e}`, r.appendChild(document.createTextNode(\": \")), r.appendChild(oe(t)), r;\n}\nfunction S(e, t) {\n  const n = document.createElement(\"div\");\n  return n.className = \"observablehq--field\", n.appendChild(document.createTextNode(\"  \")), n.appendChild(oe(e)), n.appendChild(document.createTextNode(\" => \")), n.appendChild(oe(t)), n;\n}\nfunction q(e) {\n  const t = document.createElement(\"div\");\n  return t.className = \"observablehq--field\", t.appendChild(document.createTextNode(\"  \")), t.appendChild(oe(e)), t;\n}\nfunction O(e) {\n  const t = window.getSelection();\n  return \"Range\" === t.type && (t.containsNode(e, !0) || t.anchorNode.isSelfOrDescendant(e) || t.focusNode.isSelfOrDescendant(e));\n}\nfunction L(e, n, a, o) {\n  let i,\n    s,\n    c,\n    l,\n    u = t(e);\n  if (e instanceof Map ? e instanceof e.constructor ? (i = `Map(${e.size})`, s = k) : (i = \"Map()\", s = U) : e instanceof Set ? e instanceof e.constructor ? (i = `Set(${e.size})`, s = M) : (i = \"Set()\", s = U) : u ? (i = `${e.constructor.name}(${e.length})`, s = R) : (l = h(e)) ? (i = `Immutable.${l.name}${\"Record\" === l.name ? \"\" : `(${e.size})`}`, u = l.arrayish, s = l.arrayish ? P : l.setish ? I : D) : (i = d(e), s = U), n) {\n    const t = document.createElement(\"span\");\n    return t.className = \"observablehq--shallow\", a && t.appendChild(r(a)), t.appendChild(document.createTextNode(i)), t.addEventListener(\"mouseup\", function (n) {\n      O(t) || (n.stopPropagation(), ie(t, L(e)));\n    }), t;\n  }\n  const f = document.createElement(\"span\");\n  f.className = \"observablehq--collapsed\", a && f.appendChild(r(a));\n  const p = f.appendChild(document.createElement(\"a\"));\n  p.innerHTML = \"<svg width=8 height=8 class='observablehq--caret'>\\n    <path d='M7 4L1 8V0z' fill='currentColor' />\\n  </svg>\", p.appendChild(document.createTextNode(`${i}${u ? \" [\" : \" {\"}`)), f.addEventListener(\"mouseup\", function (t) {\n    O(f) || (t.stopPropagation(), ie(f, y(e, 0, a, o)));\n  }, !0), s = s(e);\n  for (let e = 0; !(c = s.next()).done && e < 20; ++e) e > 0 && f.appendChild(document.createTextNode(\", \")), f.appendChild(c.value);\n  return c.done || f.appendChild(document.createTextNode(\", â€¦\")), f.appendChild(document.createTextNode(u ? \"]\" : \"}\")), f;\n}\nfunction* k(e) {\n  for (const [t, n] of e) yield z(t, n);\n  yield* U(e);\n}\nfunction* M(e) {\n  for (const t of e) yield oe(t, !0);\n  yield* U(e);\n}\nfunction* I(e) {\n  for (const t of e) yield oe(t, !0);\n}\nfunction* P(e) {\n  let t = -1,\n    n = 0;\n  for (const r = e.size; n < r; ++n) n > t + 1 && (yield F(n - t - 1)), yield oe(e.get(n), !0), t = n;\n  n > t + 1 && (yield F(n - t - 1));\n}\nfunction* R(e) {\n  let t = -1,\n    r = 0;\n  for (const n = e.length; r < n; ++r) r in e && (r > t + 1 && (yield F(r - t - 1)), yield oe(p(e, r), !0), t = r);\n  r > t + 1 && (yield F(r - t - 1));\n  for (const t in e) !n(t) && f(e, t) && (yield B(t, p(e, t), \"observablehq--key\"));\n  for (const t of u(e)) yield B(o(t), p(e, t), \"observablehq--symbol\");\n}\nfunction* U(e) {\n  for (const t in e) f(e, t) && (yield B(t, p(e, t), \"observablehq--key\"));\n  for (const t of u(e)) yield B(o(t), p(e, t), \"observablehq--symbol\");\n}\nfunction* D(e) {\n  for (const [t, n] of e) yield B(t, n, \"observablehq--key\");\n}\nfunction F(e) {\n  const t = document.createElement(\"span\");\n  return t.className = \"observablehq--empty\", t.textContent = 1 === e ? \"empty\" : `empty Ã— ${e}`, t;\n}\nfunction B(e, t, n) {\n  const r = document.createDocumentFragment(),\n    a = r.appendChild(document.createElement(\"span\"));\n  return a.className = n, a.textContent = e, r.appendChild(document.createTextNode(\": \")), r.appendChild(oe(t, !0)), r;\n}\nfunction z(e, t) {\n  const n = document.createDocumentFragment();\n  return n.appendChild(oe(e, !0)), n.appendChild(document.createTextNode(\" => \")), n.appendChild(oe(t, !0)), n;\n}\nfunction W(e, t) {\n  if (e instanceof Date || (e = new Date(+e)), isNaN(e)) return \"function\" == typeof t ? t(e) : t;\n  const n = e.getUTCHours(),\n    r = e.getUTCMinutes(),\n    a = e.getUTCSeconds(),\n    o = e.getUTCMilliseconds();\n  return `${(i = e.getUTCFullYear(), i < 0 ? `-${H(-i, 6)}` : i > 9999 ? `+${H(i, 6)}` : H(i, 4))}-${H(e.getUTCMonth() + 1, 2)}-${H(e.getUTCDate(), 2)}${n || r || a || o ? `T${H(n, 2)}:${H(r, 2)}${a || o ? `:${H(a, 2)}${o ? `.${H(o, 3)}` : \"\"}` : \"\"}Z` : \"\"}`;\n  var i;\n}\nfunction H(e, t) {\n  return `${e}`.padStart(t, \"0\");\n}\nvar V = Error.prototype.toString;\nvar G = RegExp.prototype.toString;\nfunction Y(e) {\n  return e.replace(/[\\\\`\\x00-\\x09\\x0b-\\x19]|\\${/g, Z);\n}\nfunction Z(e) {\n  var t = e.charCodeAt(0);\n  switch (t) {\n    case 8:\n      return \"\\\\b\";\n    case 9:\n      return \"\\\\t\";\n    case 11:\n      return \"\\\\v\";\n    case 12:\n      return \"\\\\f\";\n    case 13:\n      return \"\\\\r\";\n  }\n  return t < 16 ? \"\\\\x0\" + t.toString(16) : t < 32 ? \"\\\\x\" + t.toString(16) : \"\\\\\" + e;\n}\nfunction J(e, t) {\n  for (var n = 0; t.exec(e);) ++n;\n  return n;\n}\nvar K = Function.prototype.toString,\n  X = {\n    prefix: \"async Æ’\"\n  },\n  Q = {\n    prefix: \"async Æ’*\"\n  },\n  ee = {\n    prefix: \"class\"\n  },\n  te = {\n    prefix: \"Æ’\"\n  },\n  ne = {\n    prefix: \"Æ’*\"\n  };\nfunction re(e, t, n) {\n  var a = document.createElement(\"span\");\n  a.className = \"observablehq--function\", n && a.appendChild(r(n));\n  var o = a.appendChild(document.createElement(\"span\"));\n  return o.className = \"observablehq--keyword\", o.textContent = e.prefix, a.appendChild(document.createTextNode(t)), a;\n}\nconst {\n  prototype: {\n    toString: ae\n  }\n} = Object;\nfunction oe(e, t, n, a, i) {\n  let s = typeof e;\n  switch (s) {\n    case \"boolean\":\n    case \"undefined\":\n      e += \"\";\n      break;\n    case \"number\":\n      e = 0 === e && 1 / e < 0 ? \"-0\" : e + \"\";\n      break;\n    case \"bigint\":\n      e += \"n\";\n      break;\n    case \"symbol\":\n      e = o(e);\n      break;\n    case \"function\":\n      return function (e, t) {\n        var n,\n          r,\n          a = K.call(e);\n        switch (e.constructor && e.constructor.name) {\n          case \"AsyncFunction\":\n            n = X;\n            break;\n          case \"AsyncGeneratorFunction\":\n            n = Q;\n            break;\n          case \"GeneratorFunction\":\n            n = ne;\n            break;\n          default:\n            n = /^class\\b/.test(a) ? ee : te;\n        }\n        return n === ee ? re(n, \"\", t) : (r = /^(?:async\\s*)?(\\w+)\\s*=>/.exec(a)) ? re(n, \"(\" + r[1] + \")\", t) : (r = /^(?:async\\s*)?\\(\\s*(\\w+(?:\\s*,\\s*\\w+)*)?\\s*\\)/.exec(a)) || (r = /^(?:async\\s*)?function(?:\\s*\\*)?(?:\\s*\\w+)?\\s*\\(\\s*(\\w+(?:\\s*,\\s*\\w+)*)?\\s*\\)/.exec(a)) ? re(n, r[1] ? \"(\" + r[1].replace(/\\s*,\\s*/g, \", \") + \")\" : \"()\", t) : re(n, \"(â€¦)\", t);\n      }(e, a);\n    case \"string\":\n      return function (e, t, n, a) {\n        if (!1 === t) {\n          if (J(e, /[\"\\n]/g) <= J(e, /`|\\${/g)) {\n            const t = document.createElement(\"span\");\n            a && t.appendChild(r(a));\n            const n = t.appendChild(document.createElement(\"span\"));\n            return n.className = \"observablehq--string\", n.textContent = JSON.stringify(e), t;\n          }\n          const o = e.split(\"\\n\");\n          if (o.length > 20 && !n) {\n            const n = document.createElement(\"div\");\n            a && n.appendChild(r(a));\n            const i = n.appendChild(document.createElement(\"span\"));\n            i.className = \"observablehq--string\", i.textContent = \"`\" + Y(o.slice(0, 20).join(\"\\n\"));\n            const s = n.appendChild(document.createElement(\"span\")),\n              c = o.length - 20;\n            return s.textContent = `Show ${c} truncated line${c > 1 ? \"s\" : \"\"}`, s.className = \"observablehq--string-expand\", s.addEventListener(\"mouseup\", function (r) {\n              r.stopPropagation(), ie(n, oe(e, t, !0, a));\n            }), n;\n          }\n          const i = document.createElement(\"span\");\n          a && i.appendChild(r(a));\n          const s = i.appendChild(document.createElement(\"span\"));\n          return s.className = \"observablehq--string\" + (n ? \" observablehq--expanded\" : \"\"), s.textContent = \"`\" + Y(e) + \"`\", i;\n        }\n        const o = document.createElement(\"span\");\n        a && o.appendChild(r(a));\n        const i = o.appendChild(document.createElement(\"span\"));\n        return i.className = \"observablehq--string\", i.textContent = JSON.stringify(e.length > 100 ? `${e.slice(0, 50)}â€¦${e.slice(-49)}` : e), o;\n      }(e, t, n, a);\n    default:\n      if (null === e) {\n        s = null, e = \"null\";\n        break;\n      }\n      if (e instanceof Date) {\n        s = \"date\", e = W(e, \"Invalid Date\");\n        break;\n      }\n      if (e === l) {\n        s = \"forbidden\", e = \"[forbidden]\";\n        break;\n      }\n      switch (ae.call(e)) {\n        case \"[object RegExp]\":\n          s = \"regexp\", e = function (e) {\n            return G.call(e);\n          }(e);\n          break;\n        case \"[object Error]\":\n        case \"[object DOMException]\":\n          s = \"error\", e = function (e) {\n            return e.stack || V.call(e);\n          }(e);\n          break;\n        default:\n          return (n ? y : L)(e, t, a, i);\n      }\n  }\n  const c = document.createElement(\"span\");\n  a && c.appendChild(r(a));\n  const u = c.appendChild(document.createElement(\"span\"));\n  return u.className = `observablehq--${s}`, u.textContent = e, c;\n}\nfunction ie(t, n) {\n  t.classList.contains(\"observablehq--inspect\") && n.classList.add(\"observablehq--inspect\"), t.parentNode.replaceChild(n, t), e(n, \"load\");\n}\nconst se = /\\s+\\(\\d+:\\d+\\)$/m;\nclass Inspector {\n  constructor(e) {\n    if (!e) throw new Error(\"invalid node\");\n    this._node = e, e.classList.add(\"observablehq\");\n  }\n  pending() {\n    const {\n      _node: e\n    } = this;\n    e.classList.remove(\"observablehq--error\"), e.classList.add(\"observablehq--running\");\n  }\n  fulfilled(t, n) {\n    const {\n      _node: r\n    } = this;\n    if ((!function (e) {\n      return (e instanceof Element || e instanceof Text) && e instanceof e.constructor;\n    }(t) || t.parentNode && t.parentNode !== r) && (t = oe(t, !1, r.firstChild && r.firstChild.classList && r.firstChild.classList.contains(\"observablehq--expanded\"), n)).classList.add(\"observablehq--inspect\"), r.classList.remove(\"observablehq--running\", \"observablehq--error\"), r.firstChild !== t) if (r.firstChild) {\n      for (; r.lastChild !== r.firstChild;) r.removeChild(r.lastChild);\n      r.replaceChild(t, r.firstChild);\n    } else r.appendChild(t);\n    e(r, \"update\");\n  }\n  rejected(t, n) {\n    const {\n      _node: a\n    } = this;\n    for (a.classList.remove(\"observablehq--running\"), a.classList.add(\"observablehq--error\"); a.lastChild;) a.removeChild(a.lastChild);\n    var o = document.createElement(\"div\");\n    o.className = \"observablehq--inspect\", n && o.appendChild(r(n)), o.appendChild(document.createTextNode((t + \"\").replace(se, \"\"))), a.appendChild(o), e(a, \"error\", {\n      error: t\n    });\n  }\n}\nInspector.into = function (e) {\n  if (\"string\" == typeof e && null == (e = document.querySelector(e))) throw new Error(\"container not found\");\n  return function () {\n    return new Inspector(e.appendChild(document.createElement(\"div\")));\n  };\n};\nvar ce = {},\n  le = {};\nfunction ue(e) {\n  return new Function(\"d\", \"return {\" + e.map(function (e, t) {\n    return JSON.stringify(e) + \": d[\" + t + '] || \"\"';\n  }).join(\",\") + \"}\");\n}\nfunction fe(e) {\n  var t = Object.create(null),\n    n = [];\n  return e.forEach(function (e) {\n    for (var r in e) r in t || n.push(t[r] = r);\n  }), n;\n}\nfunction de(e, t) {\n  var n = e + \"\",\n    r = n.length;\n  return r < t ? new Array(t - r + 1).join(0) + n : n;\n}\nfunction pe(e) {\n  var t,\n    n = e.getUTCHours(),\n    r = e.getUTCMinutes(),\n    a = e.getUTCSeconds(),\n    o = e.getUTCMilliseconds();\n  return isNaN(e) ? \"Invalid Date\" : ((t = e.getUTCFullYear()) < 0 ? \"-\" + de(-t, 6) : t > 9999 ? \"+\" + de(t, 6) : de(t, 4)) + \"-\" + de(e.getUTCMonth() + 1, 2) + \"-\" + de(e.getUTCDate(), 2) + (o ? \"T\" + de(n, 2) + \":\" + de(r, 2) + \":\" + de(a, 2) + \".\" + de(o, 3) + \"Z\" : a ? \"T\" + de(n, 2) + \":\" + de(r, 2) + \":\" + de(a, 2) + \"Z\" : r || n ? \"T\" + de(n, 2) + \":\" + de(r, 2) + \"Z\" : \"\");\n}\nfunction me(e) {\n  var t = new RegExp('[\"' + e + \"\\n\\r]\"),\n    n = e.charCodeAt(0);\n  function r(e, t) {\n    var r,\n      a = [],\n      o = e.length,\n      i = 0,\n      s = 0,\n      c = o <= 0,\n      l = !1;\n    function u() {\n      if (c) return le;\n      if (l) return l = !1, ce;\n      var t,\n        r,\n        a = i;\n      if (34 === e.charCodeAt(a)) {\n        for (; i++ < o && 34 !== e.charCodeAt(i) || 34 === e.charCodeAt(++i););\n        return (t = i) >= o ? c = !0 : 10 === (r = e.charCodeAt(i++)) ? l = !0 : 13 === r && (l = !0, 10 === e.charCodeAt(i) && ++i), e.slice(a + 1, t - 1).replace(/\"\"/g, '\"');\n      }\n      for (; i < o;) {\n        if (10 === (r = e.charCodeAt(t = i++))) l = !0;else if (13 === r) l = !0, 10 === e.charCodeAt(i) && ++i;else if (r !== n) continue;\n        return e.slice(a, t);\n      }\n      return c = !0, e.slice(a, o);\n    }\n    for (10 === e.charCodeAt(o - 1) && --o, 13 === e.charCodeAt(o - 1) && --o; (r = u()) !== le;) {\n      for (var f = []; r !== ce && r !== le;) f.push(r), r = u();\n      t && null == (f = t(f, s++)) || a.push(f);\n    }\n    return a;\n  }\n  function a(t, n) {\n    return t.map(function (t) {\n      return n.map(function (e) {\n        return i(t[e]);\n      }).join(e);\n    });\n  }\n  function o(t) {\n    return t.map(i).join(e);\n  }\n  function i(e) {\n    return null == e ? \"\" : e instanceof Date ? pe(e) : t.test(e += \"\") ? '\"' + e.replace(/\"/g, '\"\"') + '\"' : e;\n  }\n  return {\n    parse: function (e, t) {\n      var n,\n        a,\n        o = r(e, function (e, r) {\n          if (n) return n(e, r - 1);\n          a = e, n = t ? function (e, t) {\n            var n = ue(e);\n            return function (r, a) {\n              return t(n(r), a, e);\n            };\n          }(e, t) : ue(e);\n        });\n      return o.columns = a || [], o;\n    },\n    parseRows: r,\n    format: function (t, n) {\n      return null == n && (n = fe(t)), [n.map(i).join(e)].concat(a(t, n)).join(\"\\n\");\n    },\n    formatBody: function (e, t) {\n      return null == t && (t = fe(e)), a(e, t).join(\"\\n\");\n    },\n    formatRows: function (e) {\n      return e.map(o).join(\"\\n\");\n    },\n    formatRow: o,\n    formatValue: i\n  };\n}\nvar he = me(\",\"),\n  be = he.parse,\n  we = he.parseRows,\n  ve = me(\"\\t\"),\n  ye = ve.parse,\n  _e = ve.parseRows;\nfunction ge(e) {\n  for (var t in e) {\n    var n,\n      r,\n      a = e[t].trim();\n    if (a) {\n      if (\"true\" === a) a = !0;else if (\"false\" === a) a = !1;else if (\"NaN\" === a) a = NaN;else if (isNaN(n = +a)) {\n        if (!(r = a.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/))) continue;\n        Ee && r[4] && !r[7] && (a = a.replace(/-/g, \"/\").replace(/T/, \" \")), a = new Date(a);\n      } else a = n;\n    } else a = null;\n    e[t] = a;\n  }\n  return e;\n}\nconst Ee = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();\nfunction Ce(e, t, n) {\n  return {\n    resolve: (r = n) => `${e}@${t}/${r}`\n  };\n}\nconst Ne = Ce(\"d3\", \"7.8.5\", \"dist/d3.min.js\"),\n  xe = Ce(\"@observablehq/inputs\", \"0.10.6\", \"dist/inputs.min.js\"),\n  Te = Ce(\"@observablehq/plot\", \"0.6.10\", \"dist/plot.umd.min.js\"),\n  Ae = Ce(\"@observablehq/graphviz\", \"0.2.1\", \"dist/graphviz.min.js\"),\n  je = Ce(\"@observablehq/highlight.js\", \"2.0.0\", \"highlight.min.js\"),\n  $e = Ce(\"@observablehq/katex\", \"0.11.1\", \"dist/katex.min.js\"),\n  Se = Ce(\"lodash\", \"4.17.21\", \"lodash.min.js\"),\n  qe = Ce(\"htl\", \"0.3.1\", \"dist/htl.min.js\"),\n  Oe = Ce(\"jszip\", \"3.10.1\", \"dist/jszip.min.js\"),\n  Le = Ce(\"marked\", \"0.3.12\", \"marked.min.js\"),\n  ke = Ce(\"sql.js\", \"1.8.0\", \"dist/sql-wasm.js\"),\n  Me = Ce(\"vega\", \"5.22.1\", \"build/vega.min.js\"),\n  Ie = Ce(\"vega-lite\", \"5.6.0\", \"build/vega-lite.min.js\"),\n  Pe = Ce(\"vega-lite-api\", \"5.0.0\", \"build/vega-lite-api.min.js\"),\n  Re = Ce(\"apache-arrow\", \"4.0.1\", \"Arrow.es2015.min.js\"),\n  Ue = Ce(\"apache-arrow\", \"9.0.0\", \"+esm\"),\n  De = Ce(\"apache-arrow\", \"11.0.0\", \"+esm\"),\n  Fe = Ce(\"arquero\", \"4.8.8\", \"dist/arquero.min.js\"),\n  Be = Ce(\"topojson-client\", \"3.1.0\", \"dist/topojson-client.min.js\"),\n  ze = Ce(\"exceljs\", \"4.3.0\", \"dist/exceljs.min.js\"),\n  We = Ce(\"mermaid\", \"9.2.2\", \"dist/mermaid.min.js\"),\n  He = Ce(\"leaflet\", \"1.9.3\", \"dist/leaflet.js\"),\n  Ve = Ce(\"@duckdb/duckdb-wasm\", \"1.24.0\", \"+esm\"),\n  Ge = new Map(),\n  Ye = [],\n  Ze = Ye.map,\n  Je = Ye.some,\n  Ke = Ye.hasOwnProperty,\n  Xe = /^((?:@[^/@]+\\/)?[^/@]+)(?:@([^/]+))?(?:\\/(.*))?$/,\n  Qe = /^\\d+\\.\\d+\\.\\d+(-[\\w-.+]+)?$/,\n  et = /(?:\\.[^/]*|\\/)$/;\nclass RequireError extends Error {\n  constructor(e) {\n    super(e);\n  }\n}\nfunction tt(e) {\n  const t = Xe.exec(e);\n  return t && {\n    name: t[1],\n    version: t[2],\n    path: t[3]\n  };\n}\nfunction nt(e = \"https://cdn.jsdelivr.net/npm/\", t = [\"unpkg\", \"jsdelivr\", \"browser\", \"main\"]) {\n  if (!/\\/$/.test(e)) throw new Error(\"origin lacks trailing slash\");\n  function n(t) {\n    const n = `${e}${t.name}${t.version ? `@${t.version}` : \"\"}/package.json`;\n    let r = Ge.get(n);\n    return r || Ge.set(n, r = fetch(n).then(e => {\n      if (!e.ok) throw new RequireError(\"unable to load package.json\");\n      return e.redirected && !Ge.has(e.url) && Ge.set(e.url, r), e.json();\n    })), r;\n  }\n  return async function (r, a) {\n    if (r.startsWith(e) && (r = r.substring(e.length)), /^(\\w+:)|\\/\\//i.test(r)) return r;\n    if (/^[.]{0,2}\\//i.test(r)) return new URL(r, null == a ? location : a).href;\n    if (!r.length || /^[\\s._]/.test(r) || /\\s$/.test(r)) throw new RequireError(\"illegal name\");\n    const o = tt(r);\n    if (!o) return `${e}${r}`;\n    if (!o.version && null != a && a.startsWith(e)) {\n      const t = await n(tt(a.substring(e.length)));\n      o.version = t.dependencies && t.dependencies[o.name] || t.peerDependencies && t.peerDependencies[o.name];\n    }\n    if (o.path && !et.test(o.path) && (o.path += \".js\"), o.path && o.version && Qe.test(o.version)) return `${e}${o.name}@${o.version}/${o.path}`;\n    const i = await n(o);\n    return `${e}${i.name}@${i.version}/${o.path || function (e) {\n      for (const n of t) {\n        let t = e[n];\n        if (\"string\" == typeof t) return t.startsWith(\"./\") && (t = t.slice(2)), et.test(t) ? t : `${t}.js`;\n      }\n    }(i) || \"index.js\"}`;\n  };\n}\nRequireError.prototype.name = RequireError.name;\nvar rt = at(nt());\nfunction at(e) {\n  const t = new Map(),\n    n = a(null);\n  function r(e) {\n    if (\"string\" != typeof e) return e;\n    let n = t.get(e);\n    return n || t.set(e, n = new Promise((t, n) => {\n      const r = document.createElement(\"script\");\n      r.onload = () => {\n        try {\n          t(Ye.pop()(a(e)));\n        } catch (e) {\n          n(new RequireError(\"invalid module\"));\n        }\n        r.remove();\n      }, r.onerror = () => {\n        n(new RequireError(\"unable to load module\")), r.remove();\n      }, r.async = !0, r.src = e, window.define = ct, document.head.appendChild(r);\n    })), n;\n  }\n  function a(t) {\n    return n => Promise.resolve(e(n, t)).then(r);\n  }\n  function o(e) {\n    return arguments.length > 1 ? Promise.all(Ze.call(arguments, n)).then(ot) : n(e);\n  }\n  return o.alias = function (t) {\n    return at((n, r) => n in t && (r = null, \"string\" != typeof (n = t[n])) ? n : e(n, r));\n  }, o.resolve = e, o;\n}\nfunction ot(e) {\n  const t = {};\n  for (const n of e) for (const e in n) Ke.call(n, e) && (null == n[e] ? Object.defineProperty(t, e, {\n    get: it(n, e)\n  }) : t[e] = n[e]);\n  return t;\n}\nfunction it(e, t) {\n  return () => e[t];\n}\nfunction st(e) {\n  return \"exports\" === (e += \"\") || \"module\" === e;\n}\nfunction ct(e, t, n) {\n  const r = arguments.length;\n  r < 2 ? (n = e, t = []) : r < 3 && (n = t, t = \"string\" == typeof e ? [] : e), Ye.push(Je.call(t, st) ? e => {\n    const r = {},\n      a = {\n        exports: r\n      };\n    return Promise.all(Ze.call(t, t => \"exports\" === (t += \"\") ? r : \"module\" === t ? a : e(t))).then(e => (n.apply(null, e), a.exports));\n  } : e => Promise.all(Ze.call(t, e)).then(e => \"function\" == typeof n ? n.apply(null, e) : n));\n}\nct.amd = {};\nconst lt = \"https://cdn.observableusercontent.com/npm/\";\nlet ut,\n  ft = rt;\nasync function dt(e) {\n  const [t, n] = await Promise.all([e(ke.resolve()), e.resolve(ke.resolve(\"dist/\"))]);\n  return t({\n    locateFile: e => `${n}${e}`\n  });\n}\nclass SQLiteDatabaseClient {\n  constructor(e) {\n    Object.defineProperties(this, {\n      _db: {\n        value: e\n      }\n    });\n  }\n  static async open(e) {\n    const [t, n] = await Promise.all([dt(ft), Promise.resolve(e).then(mt)]);\n    return new SQLiteDatabaseClient(new t.Database(n));\n  }\n  async query(e, t) {\n    return await async function (e, t, n) {\n      const [r] = await e.exec(t, n);\n      if (!r) return [];\n      const {\n          columns: a,\n          values: o\n        } = r,\n        i = o.map(e => Object.fromEntries(e.map((e, t) => [a[t], e])));\n      return i.columns = a, i;\n    }(this._db, e, t);\n  }\n  async queryRow(e, t) {\n    return (await this.query(e, t))[0] || null;\n  }\n  async explain(e, t) {\n    return ht(\"pre\", {\n      className: \"observablehq--inspect\"\n    }, [bt((await this.query(`EXPLAIN QUERY PLAN ${e}`, t)).map(e => e.detail).join(\"\\n\"))]);\n  }\n  async describeTables({\n    schema: e\n  } = {}) {\n    return this.query(`SELECT NULLIF(schema, 'main') AS schema, name FROM pragma_table_list() WHERE type = 'table'${null == e ? \"\" : \" AND schema = ?\"} AND name NOT LIKE 'sqlite_%' ORDER BY schema, name`, null == e ? [] : [e]);\n  }\n  async describeColumns({\n    schema: e,\n    table: t\n  } = {}) {\n    if (null == t) throw new Error(\"missing table\");\n    const n = await this.query(`SELECT name, type, \"notnull\" FROM pragma_table_info(?${null == e ? \"\" : \", ?\"}) ORDER BY cid`, null == e ? [t] : [t, e]);\n    if (!n.length) throw new Error(`table not found: ${t}`);\n    return n.map(({\n      name: e,\n      type: t,\n      notnull: n\n    }) => ({\n      name: e,\n      type: pt(t),\n      databaseType: t,\n      nullable: !n\n    }));\n  }\n  async describe(e) {\n    const t = await (void 0 === e ? this.query(\"SELECT name FROM sqlite_master WHERE type = 'table'\") : this.query(\"SELECT * FROM pragma_table_info(?)\", [e]));\n    if (!t.length) throw new Error(\"Not found\");\n    const {\n      columns: n\n    } = t;\n    return ht(\"table\", {\n      value: t\n    }, [ht(\"thead\", [ht(\"tr\", n.map(e => ht(\"th\", [bt(e)])))]), ht(\"tbody\", t.map(e => ht(\"tr\", n.map(t => ht(\"td\", [bt(e[t])])))))]);\n  }\n  async sql() {\n    return this.query(...this.queryTag.apply(this, arguments));\n  }\n  queryTag(e, ...t) {\n    return [e.join(\"?\"), t];\n  }\n}\nfunction pt(e) {\n  switch (e) {\n    case \"NULL\":\n      return \"null\";\n    case \"INT\":\n    case \"INTEGER\":\n    case \"TINYINT\":\n    case \"SMALLINT\":\n    case \"MEDIUMINT\":\n    case \"BIGINT\":\n    case \"UNSIGNED BIG INT\":\n    case \"INT2\":\n    case \"INT8\":\n      return \"integer\";\n    case \"TEXT\":\n    case \"CLOB\":\n    case \"DATE\":\n    case \"DATETIME\":\n      return \"string\";\n    case \"REAL\":\n    case \"DOUBLE\":\n    case \"DOUBLE PRECISION\":\n    case \"FLOAT\":\n    case \"NUMERIC\":\n      return \"number\";\n    case \"BLOB\":\n      return \"buffer\";\n    default:\n      return /^(?:(?:(?:VARYING|NATIVE) )?CHARACTER|(?:N|VAR|NVAR)CHAR)\\(/.test(e) ? \"string\" : /^(?:DECIMAL|NUMERIC)\\(/.test(e) ? \"number\" : \"other\";\n  }\n}\nfunction mt(e) {\n  return \"string\" == typeof e ? fetch(e).then(mt) : e instanceof Response || e instanceof Blob ? e.arrayBuffer().then(mt) : e instanceof ArrayBuffer ? new Uint8Array(e) : e;\n}\nfunction ht(e, t, n) {\n  2 === arguments.length && (n = t, t = void 0);\n  const r = document.createElement(e);\n  if (void 0 !== t) for (const e in t) r[e] = t[e];\n  if (void 0 !== n) for (const e of n) r.appendChild(e);\n  return r;\n}\nfunction bt(e) {\n  return document.createTextNode(e);\n}\nfunction wt(e, t) {\n  return null == e || null == t ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;\n}\nfunction vt(e, t = wt) {\n  let n,\n    r = !1;\n  if (1 === t.length) {\n    let a;\n    for (const o of e) {\n      const e = t(o);\n      (r ? wt(e, a) > 0 : 0 === wt(e, e)) && (n = o, a = e, r = !0);\n    }\n  } else for (const a of e) (r ? t(a, n) > 0 : 0 === t(a, a)) && (n = a, r = !0);\n  return n;\n}\nfunction yt(e) {\n  return e && \"function\" == typeof e.toArrowBuffer;\n}\nfunction _t(e) {\n  return e && \"function\" == typeof e.getChild && \"function\" == typeof e.toArray && e.schema && Array.isArray(e.schema.fields);\n}\nfunction gt(e) {\n  return {\n    name: e.name,\n    type: Et(e.type),\n    nullable: e.nullable,\n    databaseType: String(e.type)\n  };\n}\nfunction Et(e) {\n  switch (e.typeId) {\n    case 2:\n      return \"integer\";\n    case 3:\n    case 7:\n      return \"number\";\n    case 4:\n    case 15:\n      return \"buffer\";\n    case 5:\n      return \"string\";\n    case 6:\n      return \"boolean\";\n    case 8:\n    case 9:\n    case 10:\n      return \"date\";\n    case 12:\n    case 16:\n      return \"array\";\n    case 13:\n    case 14:\n      return \"object\";\n    default:\n      return \"other\";\n  }\n}\nasync function Ct() {\n  return await __webpack_require__(\"./src lazy recursive ^.*.*$\")(`${lt}${De.resolve()}`);\n}\nObject.defineProperty(SQLiteDatabaseClient.prototype, \"dialect\", {\n  value: \"sqlite\"\n});\nclass DuckDBClient {\n  constructor(e) {\n    Object.defineProperties(this, {\n      _db: {\n        value: e\n      }\n    });\n  }\n  async queryStream(e, t) {\n    const n = await this._db.connect();\n    let r, a;\n    try {\n      if (t?.length > 0) {\n        const a = await n.prepare(e);\n        r = await a.send(...t);\n      } else r = await n.send(e);\n      if (a = await r.next(), a.done) throw new Error(\"missing first batch\");\n    } catch (e) {\n      throw await n.close(), e;\n    }\n    return {\n      schema: (o = a.value, o.schema.fields.map(gt)),\n      async *readRows() {\n        try {\n          for (; !a.done;) yield a.value.toArray(), a = await r.next();\n        } finally {\n          await n.close();\n        }\n      }\n    };\n    var o;\n  }\n  async query(e, t) {\n    const n = await this.queryStream(e, t),\n      r = [];\n    for await (const e of n.readRows()) for (const t of e) r.push(t);\n    return r.schema = n.schema, r;\n  }\n  async queryRow(e, t) {\n    const n = (await this.queryStream(e, t)).readRows();\n    try {\n      const {\n        done: e,\n        value: t\n      } = await n.next();\n      return e || !t.length ? null : t[0];\n    } finally {\n      await n.return();\n    }\n  }\n  async sql(e, ...t) {\n    return await this.query(e.join(\"?\"), t);\n  }\n  queryTag(e, ...t) {\n    return [e.join(\"?\"), t];\n  }\n  escape(e) {\n    return `\"${e}\"`;\n  }\n  async describeTables() {\n    return (await this.query(\"SHOW TABLES\")).map(({\n      name: e\n    }) => ({\n      name: e\n    }));\n  }\n  async describeColumns({\n    table: e\n  } = {}) {\n    return (await this.query(`DESCRIBE ${this.escape(e)}`)).map(({\n      column_name: e,\n      column_type: t,\n      null: n\n    }) => ({\n      name: e,\n      type: At(t),\n      nullable: \"NO\" !== n,\n      databaseType: t\n    }));\n  }\n  static async of(e = {}, t = {}) {\n    const n = await async function () {\n      void 0 === ut && (ut = async function () {\n        const e = await __webpack_require__(\"./src lazy recursive ^.*.*$\")(`${lt}${Ve.resolve()}`),\n          t = await e.selectBundle({\n            mvp: {\n              mainModule: `${lt}${Ve.resolve(\"dist/duckdb-mvp.wasm\")}`,\n              mainWorker: `${lt}${Ve.resolve(\"dist/duckdb-browser-mvp.worker.js\")}`\n            },\n            eh: {\n              mainModule: `${lt}${Ve.resolve(\"dist/duckdb-eh.wasm\")}`,\n              mainWorker: `${lt}${Ve.resolve(\"dist/duckdb-browser-eh.worker.js\")}`\n            }\n          }),\n          n = new e.ConsoleLogger();\n        return {\n          module: e,\n          bundle: t,\n          logger: n\n        };\n      }());\n      const {\n          module: e,\n          bundle: t,\n          logger: n\n        } = await ut,\n        r = await e.createWorker(t.mainWorker),\n        a = new e.AsyncDuckDB(n, r);\n      return await a.instantiate(t.mainModule), a;\n    }();\n    return void 0 === t.query?.castTimestampToDate && (t = {\n      ...t,\n      query: {\n        ...t.query,\n        castTimestampToDate: !0\n      }\n    }), void 0 === t.query?.castBigIntToDouble && (t = {\n      ...t,\n      query: {\n        ...t.query,\n        castBigIntToDouble: !0\n      }\n    }), await n.open(t), await Promise.all(Object.entries(e).map(async ([e, t]) => {\n      if (t instanceof FileAttachment) await Nt(n, e, t);else if (_t(t)) await xt(n, e, t);else if (Array.isArray(t)) await Tt(n, e, t);else if (yt(t)) await async function (e, t, n) {\n        const r = (await Ct()).tableFromIPC(n.toArrowBuffer());\n        return await xt(e, t, r);\n      }(n, e, t);else if (\"data\" in t) {\n        const {\n          data: r,\n          ...a\n        } = t;\n        _t(r) ? await xt(n, e, r, a) : await Tt(n, e, r, a);\n      } else {\n        if (!(\"file\" in t)) throw new Error(`invalid source: ${t}`);\n        {\n          const {\n            file: r,\n            ...a\n          } = t;\n          await Nt(n, e, r, a);\n        }\n      }\n    })), new DuckDBClient(n);\n  }\n}\nasync function Nt(e, t, n, r) {\n  const a = await n.url();\n  if (a.startsWith(\"blob:\")) {\n    const t = await n.arrayBuffer();\n    await e.registerFileBuffer(n.name, new Uint8Array(t));\n  } else await e.registerFileURL(n.name, a, 4);\n  const o = await e.connect();\n  try {\n    switch (n.mimeType) {\n      case \"text/csv\":\n      case \"text/tab-separated-values\":\n        return await o.insertCSVFromPath(n.name, {\n          name: t,\n          schema: \"main\",\n          ...r\n        }).catch(async e => {\n          if (e.toString().includes(\"Could not convert\")) return await async function (e, t, n) {\n            const r = await e.prepare(`CREATE TABLE '${n}' AS SELECT * FROM read_csv_auto(?, ALL_VARCHAR=TRUE)`);\n            return await r.send(t.name);\n          }(o, n, t);\n          throw e;\n        });\n      case \"application/json\":\n        return await o.insertJSONFromPath(n.name, {\n          name: t,\n          schema: \"main\",\n          ...r\n        });\n      default:\n        if (/\\.arrow$/i.test(n.name)) {\n          const e = new Uint8Array(await n.arrayBuffer());\n          return await o.insertArrowFromIPCStream(e, {\n            name: t,\n            schema: \"main\",\n            ...r\n          });\n        }\n        if (/\\.parquet$/i.test(n.name)) return await o.query(`CREATE VIEW '${t}' AS SELECT * FROM parquet_scan('${n.name}')`);\n        throw new Error(`unknown file type: ${n.mimeType}`);\n    }\n  } finally {\n    await o.close();\n  }\n}\nasync function xt(e, t, n, r) {\n  const a = await e.connect();\n  try {\n    await a.insertArrowTable(n, {\n      name: t,\n      schema: \"main\",\n      ...r\n    });\n  } finally {\n    await a.close();\n  }\n}\nasync function Tt(e, t, n, r) {\n  const a = (await Ct()).tableFromJSON(n);\n  return await xt(e, t, a, r);\n}\nfunction At(e) {\n  switch (e) {\n    case \"BIGINT\":\n    case \"HUGEINT\":\n    case \"UBIGINT\":\n      return \"bigint\";\n    case \"DOUBLE\":\n    case \"REAL\":\n    case \"FLOAT\":\n      return \"number\";\n    case \"INTEGER\":\n    case \"SMALLINT\":\n    case \"TINYINT\":\n    case \"USMALLINT\":\n    case \"UINTEGER\":\n    case \"UTINYINT\":\n      return \"integer\";\n    case \"BOOLEAN\":\n      return \"boolean\";\n    case \"DATE\":\n    case \"TIMESTAMP\":\n    case \"TIMESTAMP WITH TIME ZONE\":\n      return \"date\";\n    case \"VARCHAR\":\n    case \"UUID\":\n      return \"string\";\n    default:\n      return /^DECIMAL\\(/.test(e) ? \"integer\" : \"other\";\n  }\n}\nObject.defineProperty(DuckDBClient.prototype, \"dialect\", {\n  value: \"duckdb\"\n});\nfunction jt(e) {\n  return Array.isArray(e) && ($t(e.schema) || St(e.columns) || function (e) {\n    const t = Math.min(20, e.length);\n    for (let n = 0; n < t; ++n) {\n      const t = e[n];\n      if (null === t || \"object\" != typeof t) return !1;\n    }\n    return t > 0 && function (e) {\n      for (const t in e) return !0;\n      return !1;\n    }(e[0]);\n  }(e) || Lt(e) || kt(e)) || Mt(e);\n}\nfunction $t(e) {\n  return Array.isArray(e) && e.every(qt);\n}\nfunction St(e) {\n  return Array.isArray(e) && e.every(e => \"string\" == typeof e);\n}\nfunction qt(e) {\n  return e && \"string\" == typeof e.name && \"string\" == typeof e.type;\n}\nfunction Ot(e) {\n  return Mt(e) || Lt(e) || kt(e);\n}\nfunction Lt(e) {\n  const t = Math.min(20, e.length);\n  if (!(t > 0)) return !1;\n  let n,\n    r = !1;\n  for (let a = 0; a < t; ++a) {\n    const t = e[a];\n    if (null == t) continue;\n    const o = typeof t;\n    if (void 0 === n) switch (o) {\n      case \"number\":\n      case \"boolean\":\n      case \"string\":\n      case \"bigint\":\n        n = o;\n        break;\n      default:\n        return !1;\n    } else if (o !== n) return !1;\n    r = !0;\n  }\n  return r;\n}\nfunction kt(e) {\n  const t = Math.min(20, e.length);\n  if (!(t > 0)) return !1;\n  let n = !1;\n  for (let r = 0; r < t; ++r) {\n    const t = e[r];\n    if (null != t) {\n      if (!(t instanceof Date)) return !1;\n      n = !0;\n    }\n  }\n  return n;\n}\nfunction Mt(e) {\n  return e instanceof Int8Array || e instanceof Int16Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Uint16Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array;\n}\nconst It = Object.assign(async (e, t, n, r) => {\n  if (e = await Rt(await e, r), (a = e) && (\"function\" == typeof a.sql || \"function\" == typeof a.queryTag && (\"function\" == typeof a.query || \"function\" == typeof a.queryStream)) && (\"table\" !== o || \"function\" == typeof a.describeColumns) && a !== It) return Ft(e, function (e, t) {\n    const n = \"function\" == typeof t.escape ? t.escape : e => e,\n      {\n        select: r,\n        from: a,\n        filter: o,\n        sort: i,\n        slice: s\n      } = e;\n    if (!a.table) throw new Error(\"missing from table\");\n    if (r.columns && 0 === r.columns.length) throw new Error(\"at least one column must be selected\");\n    const c = new Map(e.names?.map(({\n        column: e,\n        name: t\n      }) => [e, t])),\n      l = [[`SELECT ${r.columns ? r.columns.map(e => {\n        const t = c.get(e);\n        return t ? `${n(e)} AS ${n(t)}` : n(e);\n      }).join(\", \") : \"*\"} FROM ${Bt(a.table, n)}`]];\n    for (let e = 0; e < o.length; ++e) zt(e ? \"\\nAND \" : \"\\nWHERE \", l), Ht(o[e], l, n);\n    for (let e = 0; e < i.length; ++e) zt(e ? \", \" : \"\\nORDER BY \", l), Wt(i[e], l, n);\n    if (\"mssql\" === t.dialect || \"oracle\" === t.dialect) {\n      if (null !== s.to || null !== s.from) {\n        if (!i.length) {\n          if (!r.columns) throw new Error(\"at least one column must be explicitly specified. Received '*'.\");\n          zt(\"\\nORDER BY \", l), Wt({\n            column: r.columns[0],\n            direction: \"ASC\"\n          }, l, n);\n        }\n        zt(`\\nOFFSET ${s.from || 0} ROWS`, l), zt(`\\nFETCH NEXT ${null !== s.to ? s.to - (s.from || 0) : 1e9} ROWS ONLY`, l);\n      }\n    } else null === s.to && null === s.from || zt(\"\\nLIMIT \" + (null !== s.to ? s.to - (s.from || 0) : 1e9), l), null !== s.from && zt(` OFFSET ${s.from}`, l);\n    return l;\n  }(t, e), n);\n  var a, o;\n  if (jt(e)) return function (e, t) {\n    const n = new Map(),\n      r = e,\n      a = un(e, t);\n    e = a.source;\n    let o = a.schema;\n    if (t.derive) {\n      const r = [];\n      t.derive.map(({\n        name: a,\n        value: o\n      }) => {\n        let i = [];\n        fn(e, t).map((e, t) => {\n          let n;\n          try {\n            n = o(e);\n          } catch (e) {\n            i.push({\n              index: t,\n              error: e\n            }), n = void 0;\n          }\n          r[t] ? r[t] = {\n            ...r[t],\n            [a]: n\n          } : r.push({\n            [a]: n\n          });\n        }), i.length && n.set(a, i);\n      });\n      const a = un(r, t);\n      e = e.map((e, t) => ({\n        ...e,\n        ...a.source[t]\n      })), o = [...o, ...a.schema];\n    }\n    for (const {\n      type: n,\n      operands: r\n    } of t.filter) {\n      const [{\n          value: t\n        }] = r,\n        a = r.slice(1).map(({\n          value: e\n        }) => e);\n      switch (n) {\n        case \"v\":\n          {\n            const [n] = a,\n              r = sn(n);\n            e = e.filter(e => r(e[t]));\n            break;\n          }\n        case \"nv\":\n          {\n            const [n] = a,\n              r = sn(n);\n            e = e.filter(e => !r(e[t]));\n            break;\n          }\n        case \"eq\":\n          {\n            const [n] = a;\n            if (n instanceof Date) {\n              const r = +n;\n              e = e.filter(e => +e[t] === r);\n            } else e = e.filter(e => e[t] === n);\n            break;\n          }\n        case \"ne\":\n          {\n            const [n] = a;\n            e = e.filter(e => e[t] !== n);\n            break;\n          }\n        case \"c\":\n          {\n            const [n] = a;\n            e = e.filter(e => \"string\" == typeof e[t] && e[t].includes(n));\n            break;\n          }\n        case \"nc\":\n          {\n            const [n] = a;\n            e = e.filter(e => \"string\" == typeof e[t] && !e[t].includes(n));\n            break;\n          }\n        case \"in\":\n          {\n            const n = new Set(a);\n            e = e.filter(e => n.has(e[t]));\n            break;\n          }\n        case \"nin\":\n          {\n            const n = new Set(a);\n            e = e.filter(e => !n.has(e[t]));\n            break;\n          }\n        case \"n\":\n          e = e.filter(e => null == e[t]);\n          break;\n        case \"nn\":\n          e = e.filter(e => null != e[t]);\n          break;\n        case \"lt\":\n          {\n            const [n] = a;\n            e = e.filter(e => e[t] < n);\n            break;\n          }\n        case \"lte\":\n          {\n            const [n] = a;\n            e = e.filter(e => e[t] <= n);\n            break;\n          }\n        case \"gt\":\n          {\n            const [n] = a;\n            e = e.filter(e => e[t] > n);\n            break;\n          }\n        case \"gte\":\n          {\n            const [n] = a;\n            e = e.filter(e => e[t] >= n);\n            break;\n          }\n        default:\n          throw new Error(`unknown filter type: ${n}`);\n      }\n    }\n    for (const {\n      column: n,\n      direction: a\n    } of function (e) {\n      if (\"function\" != typeof e[Symbol.iterator]) throw new TypeError(\"values is not iterable\");\n      return Array.from(e).reverse();\n    }(t.sort)) {\n      const t = \"desc\" === a ? Zt : Yt;\n      e === r && (e = e.slice()), e.sort((e, r) => t(e[n], r[n]));\n    }\n    let {\n      from: i,\n      to: s\n    } = t.slice;\n    i = null == i ? 0 : Math.max(0, i), s = null == s ? 1 / 0 : Math.max(0, s), (i > 0 || s < 1 / 0) && (e = e.slice(Math.max(0, i), Math.max(0, s)));\n    let c = o.slice();\n    if (t.select.columns) {\n      if (o) {\n        const e = new Map(o.map(e => [e.name, e]));\n        o = t.select.columns.map(t => e.get(t));\n      }\n      e = e.map(e => Object.fromEntries(t.select.columns.map(t => [t, e[t]])));\n    }\n    if (t.names) {\n      const n = new Map(t.names.map(e => [e.column, e]));\n      o && (o = o.map(e => {\n        const t = n.get(e.name);\n        return {\n          ...e,\n          ...(t ? {\n            name: t.name\n          } : null)\n        };\n      })), c && (c = c.map(e => {\n        const t = n.get(e.name);\n        return {\n          ...e,\n          ...(t ? {\n            name: t.name\n          } : null)\n        };\n      })), e = fn(e, t);\n    }\n    e !== r && o && (e.schema = o);\n    return e.fullSchema = c, e.errors = n, e;\n  }(e, t);\n  if (!e) throw new Error(\"missing data source\");\n  throw new Error(\"invalid data source\");\n}, {\n  sql: (e, t, n) => async function () {\n    return Ft(await Ut(await e, n), arguments, t);\n  }\n});\nfunction Pt(e) {\n  const t = new WeakMap();\n  return (n, r) => {\n    if (!n || \"object\" != typeof n) throw new Error(\"invalid data source\");\n    let a = t.get(n);\n    return (!a || jt(n) && n.length !== a._numRows) && (a = e(n, r), a._numRows = n.length, t.set(n, a)), a;\n  };\n}\nconst Rt = Pt(async (e, t) => {\n    if (e instanceof FileAttachment) {\n      switch (e.mimeType) {\n        case \"text/csv\":\n          return e.csv();\n        case \"text/tab-separated-values\":\n          return e.tsv();\n        case \"application/json\":\n          return e.json();\n        case \"application/x-sqlite3\":\n          return e.sqlite();\n      }\n      if (/\\.(arrow|parquet)$/i.test(e.name)) return Dt(e, t);\n      throw new Error(`unsupported file type: ${e.mimeType}`);\n    }\n    return _t(e) || yt(e) ? Dt(e, t) : jt(e) && Ot(e) ? Array.from(e, e => ({\n      value: e\n    })) : e;\n  }),\n  Ut = Pt(async (e, t) => {\n    if (e instanceof FileAttachment) {\n      switch (e.mimeType) {\n        case \"text/csv\":\n        case \"text/tab-separated-values\":\n        case \"application/json\":\n          return Dt(e, t);\n        case \"application/x-sqlite3\":\n          return e.sqlite();\n      }\n      if (/\\.(arrow|parquet)$/i.test(e.name)) return Dt(e, t);\n      throw new Error(`unsupported file type: ${e.mimeType}`);\n    }\n    return jt(e) ? Dt(await async function (e, t) {\n      const n = await Ct();\n      return Ot(e) ? n.tableFromArrays({\n        [t]: e\n      }) : n.tableFromJSON(e);\n    }(e, t), t) : _t(e) || yt(e) ? Dt(e, t) : e;\n  });\nfunction Dt(e, t = e instanceof FileAttachment ? function (e) {\n  return e.name.replace(/@\\d+(?=\\.|$)/, \"\").replace(/\\.\\w+$/, \"\");\n}(e) : \"__table\") {\n  return DuckDBClient.of({\n    [t]: e\n  });\n}\nasync function Ft(e, t, n) {\n  if (!e) throw new Error(\"missing data source\");\n  if (\"function\" == typeof e.queryTag) {\n    const r = new AbortController(),\n      a = {\n        signal: r.signal\n      };\n    if (n.then(() => r.abort(\"invalidated\")), \"function\" == typeof e.queryStream) return async function* (e) {\n      let t = performance.now();\n      const n = await e,\n        r = [];\n      r.done = !1, r.error = null, r.schema = n.schema;\n      try {\n        for await (const e of n.readRows()) {\n          performance.now() - t > 150 && r.length > 0 && (yield r, t = performance.now());\n          for (const t of e) r.push(t);\n        }\n        r.done = !0, yield r;\n      } catch (e) {\n        r.error = e, yield r;\n      }\n    }(e.queryStream(...e.queryTag.apply(e, t), a));\n    if (\"function\" == typeof e.query) return e.query(...e.queryTag.apply(e, t), a);\n  }\n  if (\"function\" == typeof e.sql) return e.sql.apply(e, t);\n  throw new Error(\"source does not implement query, queryStream, or sql\");\n}\nfunction Bt(e, t) {\n  if (\"object\" == typeof e) {\n    let n = \"\";\n    return null != e.database && (n += t(e.database) + \".\"), null != e.schema && (n += t(e.schema) + \".\"), n += t(e.table), n;\n  }\n  return t(e);\n}\nfunction zt(e, t) {\n  const n = t[0];\n  n[n.length - 1] += e;\n}\nfunction Wt({\n  column: e,\n  direction: t\n}, n, r) {\n  zt(`${r(e)} ${t.toUpperCase()}`, n);\n}\nfunction Ht({\n  type: e,\n  operands: t\n}, n, r) {\n  if (t.length < 1) throw new Error(\"Invalid operand length\");\n  if (1 === t.length || \"v\" === e || \"nv\" === e) switch (Vt(t[0], n, r), e) {\n    case \"n\":\n    case \"nv\":\n      return void zt(\" IS NULL\", n);\n    case \"nn\":\n    case \"v\":\n      return void zt(\" IS NOT NULL\", n);\n    default:\n      throw new Error(\"Invalid filter operation\");\n  }\n  if (2 !== t.length || [\"in\", \"nin\"].includes(e)) {\n    var a;\n    switch (Vt(t[0], n, r), e) {\n      case \"in\":\n        zt(\" IN (\", n);\n        break;\n      case \"nin\":\n        zt(\" NOT IN (\", n);\n        break;\n      default:\n        throw new Error(\"Invalid filter operation\");\n    }\n    !function (e, t) {\n      let n = !0;\n      for (const r of e) n ? n = !1 : zt(\",\", t), t.push(r.value), t[0].push(\"\");\n    }(t.slice(1), n), zt(\")\", n);\n  } else {\n    if ([\"c\", \"nc\"].includes(e)) {\n      switch (Vt(t[0], n, r), e) {\n        case \"c\":\n          zt(\" LIKE \", n);\n          break;\n        case \"nc\":\n          zt(\" NOT LIKE \", n);\n      }\n      return void Vt((a = t[1], {\n        ...a,\n        value: `%${a.value}%`\n      }), n, r);\n    }\n    switch (Vt(t[0], n, r), e) {\n      case \"eq\":\n        zt(\" = \", n);\n        break;\n      case \"ne\":\n        zt(\" <> \", n);\n        break;\n      case \"gt\":\n        zt(\" > \", n);\n        break;\n      case \"lt\":\n        zt(\" < \", n);\n        break;\n      case \"gte\":\n        zt(\" >= \", n);\n        break;\n      case \"lte\":\n        zt(\" <= \", n);\n        break;\n      default:\n        throw new Error(\"Invalid filter operation\");\n    }\n    Vt(t[1], n, r);\n  }\n}\nfunction Vt(e, t, n) {\n  \"column\" === e.type ? zt(n(e.value), t) : (t.push(e.value), t[0].push(\"\"));\n}\nfunction Gt(e, t) {\n  return (null == e || !(e >= e)) - (null == t || !(t >= t));\n}\nfunction Yt(e, t) {\n  return Gt(e, t) || (e < t ? -1 : e > t ? 1 : 0);\n}\nfunction Zt(e, t) {\n  return Gt(e, t) || (e > t ? -1 : e < t ? 1 : 0);\n}\nconst Jt = e => \"number\" == typeof e && !Number.isNaN(e),\n  Kt = e => Number.isInteger(e) && !Number.isNaN(e),\n  Xt = e => \"string\" == typeof e,\n  Qt = e => \"boolean\" == typeof e,\n  en = e => \"bigint\" == typeof e,\n  tn = e => e instanceof Date && !isNaN(e),\n  nn = e => e instanceof ArrayBuffer,\n  rn = e => Array.isArray(e),\n  an = e => \"object\" == typeof e && null !== e,\n  on = e => null != e;\nfunction sn(e) {\n  switch (e) {\n    case \"string\":\n      return Xt;\n    case \"bigint\":\n      return en;\n    case \"boolean\":\n      return Qt;\n    case \"number\":\n      return Jt;\n    case \"integer\":\n      return Kt;\n    case \"date\":\n      return tn;\n    case \"buffer\":\n      return nn;\n    case \"array\":\n      return rn;\n    case \"object\":\n      return an;\n    default:\n      return on;\n  }\n}\nconst cn = /^(([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2}))|(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2,4}))([T ]\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/;\nfunction ln(e, t) {\n  switch (t) {\n    case \"string\":\n      return \"string\" == typeof e || null == e ? e : String(e);\n    case \"boolean\":\n      if (\"string\" == typeof e) {\n        const t = e.trim().toLowerCase();\n        return \"true\" === t || \"false\" !== t && null;\n      }\n      return \"boolean\" == typeof e || null == e ? e : Boolean(e);\n    case \"bigint\":\n      return \"bigint\" == typeof e || null == e ? e : Number.isInteger(\"string\" != typeof e || e.trim() ? +e : NaN) ? BigInt(e) : void 0;\n    case \"integer\":\n    case \"number\":\n      return \"number\" == typeof e ? e : null == e || \"string\" == typeof e && !e.trim() ? NaN : Number(e);\n    case \"date\":\n      {\n        if (e instanceof Date || null == e) return e;\n        if (\"number\" == typeof e) return new Date(e);\n        const t = String(e).trim();\n        return \"string\" != typeof e || t ? new Date(cn.test(t) ? t : NaN) : null;\n      }\n    case \"array\":\n    case \"object\":\n    case \"buffer\":\n    case \"other\":\n      return e;\n    default:\n      throw new Error(`Unable to coerce to type: ${t}`);\n  }\n}\nfunction un(e, t) {\n  const n = e;\n  let {\n    schema: r,\n    inferred: a\n  } = function (e) {\n    const {\n      columns: t\n    } = e;\n    let {\n      schema: n\n    } = e;\n    return $t(n) ? {\n      schema: n,\n      inferred: !1\n    } : (n = mn(e, St(t) ? t : void 0), {\n      schema: n,\n      inferred: !0\n    });\n  }(e);\n  const o = new Map(r.map(({\n    name: e,\n    type: t\n  }) => [e, t]));\n  if (t.types) {\n    for (const {\n      name: e,\n      type: a\n    } of t.types) {\n      o.set(e, a), r === n.schema && (r = r.slice());\n      const t = r.findIndex(t => t.name === e);\n      t > -1 && (r[t] = {\n        ...r[t],\n        type: a\n      });\n    }\n    e = e.map(e => dn(e, o, r));\n  } else a && (e = e.map(e => dn(e, o, r)));\n  return {\n    source: e,\n    schema: r\n  };\n}\nfunction fn(e, t) {\n  if (!t.names) return e;\n  const n = new Map(t.names.map(e => [e.column, e]));\n  return e.map(e => Object.fromEntries(Object.keys(e).map(t => [n.get(t)?.name ?? t, e[t]])));\n}\nfunction dn(e, t, n) {\n  const r = {};\n  for (const a of n) {\n    const n = t.get(a.name),\n      o = e[a.name];\n    r[a.name] = \"raw\" === n ? o : ln(o, n);\n  }\n  return r;\n}\nconst pn = [\"boolean\", \"integer\", \"number\", \"date\", \"bigint\", \"array\", \"object\", \"buffer\"];\nfunction mn(e, t = function (e) {\n  const t = new Set();\n  for (const n of e) if (n) for (const e in n) Object.prototype.hasOwnProperty.call(n, e) && t.add(e);\n  return Array.from(t);\n}(e)) {\n  const n = [],\n    r = e.slice(0, 100);\n  for (const e of t) {\n    const t = {\n      boolean: 0,\n      integer: 0,\n      number: 0,\n      date: 0,\n      string: 0,\n      array: 0,\n      object: 0,\n      bigint: 0,\n      buffer: 0,\n      defined: 0\n    };\n    for (const n of r) {\n      let r = n[e];\n      if (null == r) continue;\n      const a = typeof r;\n      if (\"string\" !== a) ++t.defined, Array.isArray(r) ? ++t.array : r instanceof Date ? ++t.date : r instanceof ArrayBuffer ? ++t.buffer : \"number\" === a ? (++t.number, Number.isInteger(r) && ++t.integer) : a in t && ++t[a];else {\n        if (r = r.trim(), !r) continue;\n        ++t.defined, ++t.string, /^(true|false)$/i.test(r) ? ++t.boolean : r && !isNaN(r) ? (++t.number, Number.isInteger(+r) && ++t.integer) : cn.test(r) && ++t.date;\n      }\n    }\n    const a = Math.max(1, .9 * t.defined),\n      o = vt(pn, e => t[e] >= a ? t[e] : NaN) ?? (t.string >= a ? \"string\" : \"other\");\n    n.push({\n      name: e,\n      type: o,\n      inferred: o\n    });\n  }\n  return n;\n}\nclass Workbook {\n  constructor(e) {\n    Object.defineProperties(this, {\n      _: {\n        value: e\n      },\n      sheetNames: {\n        value: e.worksheets.map(e => e.name),\n        enumerable: !0\n      }\n    });\n  }\n  sheet(e, t) {\n    const n = \"number\" == typeof e ? this.sheetNames[e] : this.sheetNames.includes(e += \"\") ? e : null;\n    if (null == n) throw new Error(`Sheet not found: ${e}`);\n    return function (e, {\n      range: t,\n      headers: n\n    } = {}) {\n      let [[r, a], [o, i]] = function (e = \":\", {\n        columnCount: t,\n        rowCount: n\n      }) {\n        if (!(e += \"\").match(/^[A-Z]*\\d*:[A-Z]*\\d*$/)) throw new Error(\"Malformed range specifier\");\n        const [[r = 0, a = 0], [o = t - 1, i = n - 1]] = e.split(\":\").map(vn);\n        return [[r, a], [o, i]];\n      }(t, e);\n      const s = n ? e._rows[a++] : null;\n      let c = new Set([\"#\"]);\n      for (let e = r; e <= o; e++) {\n        const t = s ? hn(s.findCell(e + 1)) : null;\n        let n = t && t + \"\" || wn(e);\n        for (; c.has(n);) n += \"_\";\n        c.add(n);\n      }\n      c = new Array(r).concat(Array.from(c));\n      const l = new Array(i - a + 1);\n      for (let t = a; t <= i; t++) {\n        const n = l[t - a] = Object.create(null, {\n            \"#\": {\n              value: t + 1\n            }\n          }),\n          i = e.getRow(t + 1);\n        if (i.hasValues) for (let e = r; e <= o; e++) {\n          const t = hn(i.findCell(e + 1));\n          null != t && (n[c[e + 1]] = t);\n        }\n      }\n      return l.columns = c.filter(() => !0), l;\n    }(this._.getWorksheet(n), t);\n  }\n}\nfunction hn(e) {\n  if (!e) return;\n  const {\n    value: t\n  } = e;\n  if (t && \"object\" == typeof t && !(t instanceof Date)) {\n    if (t.formula || t.sharedFormula) return t.result && t.result.error ? NaN : t.result;\n    if (t.richText) return bn(t);\n    if (t.text) {\n      let {\n        text: e\n      } = t;\n      return e.richText && (e = bn(e)), t.hyperlink && t.hyperlink !== e ? `${t.hyperlink} ${e}` : e;\n    }\n    return t;\n  }\n  return t;\n}\nfunction bn(e) {\n  return e.richText.map(e => e.text).join(\"\");\n}\nfunction wn(e) {\n  let t = \"\";\n  e++;\n  do {\n    t = String.fromCharCode(64 + (e % 26 || 26)) + t;\n  } while (e = Math.floor((e - 1) / 26));\n  return t;\n}\nfunction vn(e) {\n  const [, t, n] = e.match(/^([A-Z]*)(\\d*)$/);\n  let r = 0;\n  if (t) for (let e = 0; e < t.length; e++) r += Math.pow(26, t.length - e - 1) * (t.charCodeAt(e) - 64);\n  return [r ? r - 1 : void 0, n ? +n - 1 : void 0];\n}\nasync function yn(e) {\n  const t = await fetch(await e.url());\n  if (!t.ok) throw new Error(`Unable to load file: ${e.name}`);\n  return t;\n}\nasync function _n(e, t, {\n  array: n = !1,\n  typed: r = !1\n} = {}) {\n  const a = await e.text(),\n    o = \"\\t\" === t ? n ? _e : ye : n ? we : be;\n  if (\"auto\" === r && !n) {\n    const e = o(a);\n    return function (e, t) {\n      const n = new Map(t.map(({\n        name: e,\n        type: t\n      }) => [e, t]));\n      return Object.assign(e.map(e => dn(e, n, t)), {\n        schema: t\n      });\n    }(e, mn(e, e.columns));\n  }\n  return o(a, r && ge);\n}\nclass gn {\n  constructor(e, t) {\n    Object.defineProperty(this, \"name\", {\n      value: e,\n      enumerable: !0\n    }), void 0 !== t && Object.defineProperty(this, \"mimeType\", {\n      value: t + \"\",\n      enumerable: !0\n    });\n  }\n  async blob() {\n    return (await yn(this)).blob();\n  }\n  async arrayBuffer() {\n    return (await yn(this)).arrayBuffer();\n  }\n  async text() {\n    return (await yn(this)).text();\n  }\n  async json() {\n    return (await yn(this)).json();\n  }\n  async stream() {\n    return (await yn(this)).body;\n  }\n  async csv(e) {\n    return _n(this, \",\", e);\n  }\n  async tsv(e) {\n    return _n(this, \"\\t\", e);\n  }\n  async image(e) {\n    const t = await this.url();\n    return new Promise((n, r) => {\n      const a = new Image();\n      new URL(t, document.baseURI).origin !== new URL(location).origin && (a.crossOrigin = \"anonymous\"), Object.assign(a, e), a.onload = () => n(a), a.onerror = () => r(new Error(`Unable to load file: ${this.name}`)), a.src = t;\n    });\n  }\n  async arrow({\n    version: e = 4\n  } = {}) {\n    switch (e) {\n      case 4:\n        {\n          const [e, t] = await Promise.all([ft(Re.resolve()), yn(this)]);\n          return e.Table.from(t);\n        }\n      case 9:\n        {\n          const [e, t] = await Promise.all([__webpack_require__(\"./src lazy recursive ^.*.*$\")(`${lt}${Ue.resolve()}`), yn(this)]);\n          return e.tableFromIPC(t);\n        }\n      case 11:\n        {\n          const [e, t] = await Promise.all([__webpack_require__(\"./src lazy recursive ^.*.*$\")(`${lt}${De.resolve()}`), yn(this)]);\n          return e.tableFromIPC(t);\n        }\n      default:\n        throw new Error(`unsupported arrow version: ${e}`);\n    }\n  }\n  async sqlite() {\n    return SQLiteDatabaseClient.open(yn(this));\n  }\n  async zip() {\n    const [e, t] = await Promise.all([ft(Oe.resolve()), this.arrayBuffer()]);\n    return new ZipArchive(await e.loadAsync(t));\n  }\n  async xml(e = \"application/xml\") {\n    return new DOMParser().parseFromString(await this.text(), e);\n  }\n  async html() {\n    return this.xml(\"text/html\");\n  }\n  async xlsx() {\n    const [e, t] = await Promise.all([ft(ze.resolve()), this.arrayBuffer()]);\n    return new Workbook(await new e.Workbook().xlsx.load(t));\n  }\n}\nclass FileAttachment extends gn {\n  constructor(e, t, n) {\n    super(t, n), Object.defineProperty(this, \"_url\", {\n      value: e\n    });\n  }\n  async url() {\n    return (await this._url) + \"\";\n  }\n}\nfunction En(e) {\n  throw new Error(`File not found: ${e}`);\n}\nclass ZipArchive {\n  constructor(e) {\n    Object.defineProperty(this, \"_\", {\n      value: e\n    }), this.filenames = Object.keys(e.files).filter(t => !e.files[t].dir);\n  }\n  file(e) {\n    const t = this._.file(e += \"\");\n    if (!t || t.dir) throw new Error(`file not found: ${e}`);\n    return new ZipArchiveEntry(t);\n  }\n}\nclass ZipArchiveEntry extends gn {\n  constructor(e) {\n    super(e.name), Object.defineProperty(this, \"_\", {\n      value: e\n    }), Object.defineProperty(this, \"_url\", {\n      writable: !0\n    });\n  }\n  async url() {\n    return this._url || (this._url = this.blob().then(URL.createObjectURL));\n  }\n  async blob() {\n    return this._.async(\"blob\");\n  }\n  async arrayBuffer() {\n    return this._.async(\"arraybuffer\");\n  }\n  async text() {\n    return this._.async(\"text\");\n  }\n  async json() {\n    return JSON.parse(await this.text());\n  }\n}\nvar Cn = {\n  math: \"http://www.w3.org/1998/Math/MathML\",\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: \"http://www.w3.org/1999/xhtml\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\nvar Nn = 0;\nfunction xn(e) {\n  return new Tn(\"O-\" + (null == e ? \"\" : e + \"-\") + ++Nn);\n}\nfunction Tn(e) {\n  this.id = e, this.href = new URL(`#${e}`, location) + \"\";\n}\nTn.prototype.toString = function () {\n  return \"url(\" + this.href + \")\";\n};\nvar An = Object.freeze({\n  __proto__: null,\n  canvas: function (e, t) {\n    var n = document.createElement(\"canvas\");\n    return n.width = e, n.height = t, n;\n  },\n  context2d: function (e, t, n) {\n    null == n && (n = devicePixelRatio);\n    var r = document.createElement(\"canvas\");\n    r.width = e * n, r.height = t * n, r.style.width = e + \"px\";\n    var a = r.getContext(\"2d\");\n    return a.scale(n, n), a;\n  },\n  download: function (e, t = \"untitled\", n = \"Save\") {\n    const r = document.createElement(\"a\"),\n      a = r.appendChild(document.createElement(\"button\"));\n    async function o() {\n      await new Promise(requestAnimationFrame), URL.revokeObjectURL(r.href), r.removeAttribute(\"href\"), a.textContent = n, a.disabled = !1;\n    }\n    return a.textContent = n, r.download = t, r.onclick = async t => {\n      if (a.disabled = !0, r.href) return o();\n      a.textContent = \"Savingâ€¦\";\n      try {\n        const t = await (\"function\" == typeof e ? e() : e);\n        a.textContent = \"Download\", r.href = URL.createObjectURL(t);\n      } catch (e) {\n        a.textContent = n;\n      }\n      if (t.eventPhase) return o();\n      a.disabled = !1;\n    }, r;\n  },\n  element: function (e, t) {\n    var n,\n      r = e += \"\",\n      a = r.indexOf(\":\");\n    a >= 0 && \"xmlns\" !== (r = e.slice(0, a)) && (e = e.slice(a + 1));\n    var o = Cn.hasOwnProperty(r) ? document.createElementNS(Cn[r], e) : document.createElement(e);\n    if (t) for (var i in t) a = (r = i).indexOf(\":\"), n = t[i], a >= 0 && \"xmlns\" !== (r = i.slice(0, a)) && (i = i.slice(a + 1)), Cn.hasOwnProperty(r) ? o.setAttributeNS(Cn[r], i, n) : o.setAttribute(i, n);\n    return o;\n  },\n  input: function (e) {\n    var t = document.createElement(\"input\");\n    return null != e && (t.type = e), t;\n  },\n  range: function (e, t, n) {\n    1 === arguments.length && (t = e, e = null);\n    var r = document.createElement(\"input\");\n    return r.min = e = null == e ? 0 : +e, r.max = t = null == t ? 1 : +t, r.step = null == n ? \"any\" : n = +n, r.type = \"range\", r;\n  },\n  select: function (e) {\n    var t = document.createElement(\"select\");\n    return Array.prototype.forEach.call(e, function (e) {\n      var n = document.createElement(\"option\");\n      n.value = n.textContent = e, t.appendChild(n);\n    }), t;\n  },\n  svg: function (e, t) {\n    var n = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    return n.setAttribute(\"viewBox\", [0, 0, e, t]), n.setAttribute(\"width\", e), n.setAttribute(\"height\", t), n;\n  },\n  text: function (e) {\n    return document.createTextNode(e);\n  },\n  uid: xn\n});\nvar jn = Object.freeze({\n  __proto__: null,\n  buffer: function (e) {\n    return new Promise(function (t, n) {\n      var r = new FileReader();\n      r.onload = function () {\n        t(r.result);\n      }, r.onerror = n, r.readAsArrayBuffer(e);\n    });\n  },\n  text: function (e) {\n    return new Promise(function (t, n) {\n      var r = new FileReader();\n      r.onload = function () {\n        t(r.result);\n      }, r.onerror = n, r.readAsText(e);\n    });\n  },\n  url: function (e) {\n    return new Promise(function (t, n) {\n      var r = new FileReader();\n      r.onload = function () {\n        t(r.result);\n      }, r.onerror = n, r.readAsDataURL(e);\n    });\n  }\n});\nfunction $n() {\n  return this;\n}\nfunction Sn(e, t) {\n  let n = !1;\n  if (\"function\" != typeof t) throw new Error(\"dispose is not a function\");\n  return {\n    [Symbol.iterator]: $n,\n    next: () => n ? {\n      done: !0\n    } : (n = !0, {\n      done: !1,\n      value: e\n    }),\n    return: () => (n = !0, t(e), {\n      done: !0\n    }),\n    throw: () => ({\n      done: n = !0\n    })\n  };\n}\nfunction qn(e) {\n  let t,\n    n,\n    r = !1;\n  const a = e(function (e) {\n    n ? (n(e), n = null) : r = !0;\n    return t = e;\n  });\n  if (null != a && \"function\" != typeof a) throw new Error(\"function\" == typeof a.then ? \"async initializers are not supported\" : \"initializer returned something, but not a dispose function\");\n  return {\n    [Symbol.iterator]: $n,\n    throw: () => ({\n      done: !0\n    }),\n    return: () => (null != a && a(), {\n      done: !0\n    }),\n    next: function () {\n      return {\n        done: !1,\n        value: r ? (r = !1, Promise.resolve(t)) : new Promise(e => n = e)\n      };\n    }\n  };\n}\nfunction On(e) {\n  switch (e.type) {\n    case \"range\":\n    case \"number\":\n      return e.valueAsNumber;\n    case \"date\":\n      return e.valueAsDate;\n    case \"checkbox\":\n      return e.checked;\n    case \"file\":\n      return e.multiple ? e.files : e.files[0];\n    case \"select-multiple\":\n      return Array.from(e.selectedOptions, e => e.value);\n    default:\n      return e.value;\n  }\n}\nvar Ln = Object.freeze({\n  __proto__: null,\n  disposable: Sn,\n  filter: function* (e, t) {\n    for (var n, r = -1; !(n = e.next()).done;) t(n.value, ++r) && (yield n.value);\n  },\n  input: function (e) {\n    return qn(function (t) {\n      var n = function (e) {\n          switch (e.type) {\n            case \"button\":\n            case \"submit\":\n            case \"checkbox\":\n              return \"click\";\n            case \"file\":\n              return \"change\";\n            default:\n              return \"input\";\n          }\n        }(e),\n        r = On(e);\n      function a() {\n        t(On(e));\n      }\n      return e.addEventListener(n, a), void 0 !== r && t(r), function () {\n        e.removeEventListener(n, a);\n      };\n    });\n  },\n  map: function* (e, t) {\n    for (var n, r = -1; !(n = e.next()).done;) yield t(n.value, ++r);\n  },\n  observe: qn,\n  queue: function (e) {\n    let t;\n    const n = [],\n      r = e(function (e) {\n        n.push(e), t && (t(n.shift()), t = null);\n        return e;\n      });\n    if (null != r && \"function\" != typeof r) throw new Error(\"function\" == typeof r.then ? \"async initializers are not supported\" : \"initializer returned something, but not a dispose function\");\n    return {\n      [Symbol.iterator]: $n,\n      throw: () => ({\n        done: !0\n      }),\n      return: () => (null != r && r(), {\n        done: !0\n      }),\n      next: function () {\n        return {\n          done: !1,\n          value: n.length ? Promise.resolve(n.shift()) : new Promise(e => t = e)\n        };\n      }\n    };\n  },\n  range: function* (e, t, n) {\n    e = +e, t = +t, n = (a = arguments.length) < 2 ? (t = e, e = 0, 1) : a < 3 ? 1 : +n;\n    for (var r = -1, a = 0 | Math.max(0, Math.ceil((t - e) / n)); ++r < a;) yield e + r * n;\n  },\n  valueAt: function (e, t) {\n    if (!(!isFinite(t = +t) || t < 0 || t != t | 0)) for (var n, r = -1; !(n = e.next()).done;) if (++r === t) return n.value;\n  },\n  worker: function (e) {\n    const t = URL.createObjectURL(new Blob([e], {\n        type: \"text/javascript\"\n      })),\n      n = new Worker(t);\n    return Sn(n, () => {\n      n.terminate(), URL.revokeObjectURL(t);\n    });\n  }\n});\nfunction kn(e, t) {\n  return function (n) {\n    var r,\n      a,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u,\n      f = n[0],\n      d = [],\n      p = null,\n      m = -1;\n    for (s = 1, c = arguments.length; s < c; ++s) {\n      if ((r = arguments[s]) instanceof Node) d[++m] = r, f += \"\\x3c!--o:\" + m + \"--\\x3e\";else if (Array.isArray(r)) {\n        for (l = 0, u = r.length; l < u; ++l) (a = r[l]) instanceof Node ? (null === p && (d[++m] = p = document.createDocumentFragment(), f += \"\\x3c!--o:\" + m + \"--\\x3e\"), p.appendChild(a)) : (p = null, f += a);\n        p = null;\n      } else f += r;\n      f += n[s];\n    }\n    if (p = e(f), ++m > 0) {\n      for (o = new Array(m), i = document.createTreeWalker(p, NodeFilter.SHOW_COMMENT, null, !1); i.nextNode();) a = i.currentNode, /^o:/.test(a.nodeValue) && (o[+a.nodeValue.slice(2)] = a);\n      for (s = 0; s < m; ++s) (a = o[s]) && a.parentNode.replaceChild(d[s], a);\n    }\n    return 1 === p.childNodes.length ? p.removeChild(p.firstChild) : 11 === p.nodeType ? ((a = t()).appendChild(p), a) : p;\n  };\n}\nconst Mn = kn(function (e) {\n  var t = document.createElement(\"template\");\n  return t.innerHTML = e.trim(), document.importNode(t.content, !0);\n}, function () {\n  return document.createElement(\"span\");\n});\nfunction In(e) {\n  let t;\n  Object.defineProperties(this, {\n    generator: {\n      value: qn(e => {\n        t = e;\n      })\n    },\n    value: {\n      get: () => e,\n      set: n => t(e = n)\n    }\n  }), void 0 !== e && t(e);\n}\nfunction* Pn() {\n  for (;;) yield Date.now();\n}\nvar Rn = new Map();\nfunction Un(e, t) {\n  var n;\n  return (n = Rn.get(e = +e)) ? n.then(() => t) : (n = Date.now()) >= e ? Promise.resolve(t) : function (e, t) {\n    var n = new Promise(function (n) {\n      Rn.delete(t);\n      var r = t - e;\n      if (!(r > 0)) throw new Error(\"invalid time\");\n      if (r > 2147483647) throw new Error(\"too long to wait\");\n      setTimeout(n, r);\n    });\n    return Rn.set(t, n), n;\n  }(n, e).then(() => t);\n}\nvar Dn = Object.freeze({\n  __proto__: null,\n  delay: function (e, t) {\n    return new Promise(function (n) {\n      setTimeout(function () {\n        n(t);\n      }, e);\n    });\n  },\n  tick: function (e, t) {\n    return Un(Math.ceil((Date.now() + 1) / e) * e, t);\n  },\n  when: Un\n});\nfunction Fn(e, t) {\n  if (/^(\\w+:)|\\/\\//i.test(e)) return e;\n  if (/^[.]{0,2}\\//i.test(e)) return new URL(e, null == t ? location : t).href;\n  if (!e.length || /^[\\s._]/.test(e) || /\\s$/.test(e)) throw new Error(\"illegal name\");\n  return \"https://unpkg.com/\" + e;\n}\nconst Bn = kn(function (e) {\n  var t = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  return t.innerHTML = e.trim(), t;\n}, function () {\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n});\nvar zn = String.raw;\nfunction Wn(e) {\n  return new Promise(function (t, n) {\n    var r = document.createElement(\"link\");\n    r.rel = \"stylesheet\", r.href = e, r.onerror = n, r.onload = t, document.head.appendChild(r);\n  });\n}\nfunction Hn() {\n  return qn(function (e) {\n    var t = e(document.body.clientWidth);\n    function n() {\n      var n = document.body.clientWidth;\n      n !== t && e(t = n);\n    }\n    return window.addEventListener(\"resize\", n), function () {\n      window.removeEventListener(\"resize\", n);\n    };\n  });\n}\nconst Library = Object.assign(Object.defineProperties(function (e) {\n  const t = function (e) {\n    return null == e ? ft : at(e);\n  }(e);\n  var n;\n  Object.defineProperties(this, (n = {\n    FileAttachment: () => En,\n    Mutable: () => In,\n    now: Pn,\n    width: Hn,\n    dot: () => t(Ae.resolve()),\n    htl: () => t(qe.resolve()),\n    html: () => Mn,\n    md: () => function (e) {\n      return e(Le.resolve()).then(function (t) {\n        return kn(function (n) {\n          var r = document.createElement(\"div\");\n          r.innerHTML = t(n, {\n            langPrefix: \"\"\n          }).trim();\n          var a = r.querySelectorAll(\"pre code[class]\");\n          return a.length > 0 && e(je.resolve()).then(function (t) {\n            a.forEach(function (n) {\n              function r() {\n                t.highlightBlock(n), n.parentNode.classList.add(\"observablehq--md-pre\");\n              }\n              t.getLanguage(n.className) ? r() : e(je.resolve(\"async-languages/index.js\")).then(r => {\n                if (r.has(n.className)) return e(je.resolve(\"async-languages/\" + r.get(n.className))).then(e => {\n                  t.registerLanguage(n.className, e);\n                });\n              }).then(r, r);\n            });\n          }), r;\n        }, function () {\n          return document.createElement(\"div\");\n        });\n      });\n    }(t),\n    svg: () => Bn,\n    tex: () => function (e) {\n      return Promise.all([e($e.resolve()), e.resolve($e.resolve(\"dist/katex.min.css\")).then(Wn)]).then(function (e) {\n        var t = e[0],\n          n = r();\n        function r(e) {\n          return function () {\n            var n = document.createElement(\"div\");\n            return t.render(zn.apply(String, arguments), n, e), n.removeChild(n.firstChild);\n          };\n        }\n        return n.options = r, n.block = r({\n          displayMode: !0\n        }), n;\n      });\n    }(t),\n    _: () => t(Se.resolve()),\n    aq: () => t.alias({\n      \"apache-arrow\": Re.resolve()\n    })(Fe.resolve()),\n    Arrow: () => t(Re.resolve()),\n    d3: () => t(Ne.resolve()),\n    DuckDBClient: () => DuckDBClient,\n    Inputs: () => t(xe.resolve()).then(e => ({\n      ...e,\n      file: e.fileOf(gn)\n    })),\n    L: () => async function (e) {\n      const t = await e(He.resolve());\n      if (!t._style) {\n        const n = document.createElement(\"link\");\n        n.rel = \"stylesheet\", n.href = await e.resolve(He.resolve(\"dist/leaflet.css\")), t._style = document.head.appendChild(n);\n      }\n      return t;\n    }(t),\n    mermaid: () => async function (e) {\n      const t = await e(We.resolve());\n      return t.initialize({\n        securityLevel: \"loose\",\n        theme: \"neutral\"\n      }), function () {\n        const e = document.createElement(\"div\");\n        return e.innerHTML = t.render(xn().id, String.raw.apply(String, arguments)), e.removeChild(e.firstChild);\n      };\n    }(t),\n    Plot: () => t(Te.resolve()),\n    __query: () => It,\n    require: () => t,\n    resolve: () => Fn,\n    SQLite: () => dt(t),\n    SQLiteDatabaseClient: () => SQLiteDatabaseClient,\n    topojson: () => t(Be.resolve()),\n    vl: () => async function (e) {\n      const [t, n, r] = await Promise.all([Me, Ie, Pe].map(t => e(t.resolve())));\n      return r.register(t, n);\n    }(t),\n    aapl: () => new FileAttachment(\"https://static.observableusercontent.com/files/3ccff97fd2d93da734e76829b2b066eafdaac6a1fafdec0faf6ebc443271cfc109d29e80dd217468fcb2aff1e6bffdc73f356cc48feb657f35378e6abbbb63b9\").csv({\n      typed: !0\n    }),\n    alphabet: () => new FileAttachment(\"https://static.observableusercontent.com/files/75d52e6c3130b1cae83cda89305e17b50f33e7420ef205587a135e8562bcfd22e483cf4fa2fb5df6dff66f9c5d19740be1cfaf47406286e2eb6574b49ffc685d\").csv({\n      typed: !0\n    }),\n    cars: () => new FileAttachment(\"https://static.observableusercontent.com/files/048ec3dfd528110c0665dfa363dd28bc516ffb7247231f3ab25005036717f5c4c232a5efc7bb74bc03037155cb72b1abe85a33d86eb9f1a336196030443be4f6\").csv({\n      typed: !0\n    }),\n    citywages: () => new FileAttachment(\"https://static.observableusercontent.com/files/39837ec5121fcc163131dbc2fe8c1a2e0b3423a5d1e96b5ce371e2ac2e20a290d78b71a4fb08b9fa6a0107776e17fb78af313b8ea70f4cc6648fad68ddf06f7a\").csv({\n      typed: !0\n    }),\n    diamonds: () => new FileAttachment(\"https://static.observableusercontent.com/files/87942b1f5d061a21fa4bb8f2162db44e3ef0f7391301f867ab5ba718b225a63091af20675f0bfe7f922db097b217b377135203a7eab34651e21a8d09f4e37252\").csv({\n      typed: !0\n    }),\n    flare: () => new FileAttachment(\"https://static.observableusercontent.com/files/a6b0d94a7f5828fd133765a934f4c9746d2010e2f342d335923991f31b14120de96b5cb4f160d509d8dc627f0107d7f5b5070d2516f01e4c862b5b4867533000\").csv({\n      typed: !0\n    }),\n    industries: () => new FileAttachment(\"https://static.observableusercontent.com/files/76f13741128340cc88798c0a0b7fa5a2df8370f57554000774ab8ee9ae785ffa2903010cad670d4939af3e9c17e5e18e7e05ed2b38b848ac2fc1a0066aa0005f\").csv({\n      typed: !0\n    }),\n    miserables: () => new FileAttachment(\"https://static.observableusercontent.com/files/31d904f6e21d42d4963ece9c8cc4fbd75efcbdc404bf511bc79906f0a1be68b5a01e935f65123670ed04e35ca8cae3c2b943f82bf8db49c5a67c85cbb58db052\").json(),\n    olympians: () => new FileAttachment(\"https://static.observableusercontent.com/files/31ca24545a0603dce099d10ee89ee5ae72d29fa55e8fc7c9ffb5ded87ac83060d80f1d9e21f4ae8eb04c1e8940b7287d179fe8060d887fb1f055f430e210007c\").csv({\n      typed: !0\n    }),\n    penguins: () => new FileAttachment(\"https://static.observableusercontent.com/files/715db1223e067f00500780077febc6cebbdd90c151d3d78317c802732252052ab0e367039872ab9c77d6ef99e5f55a0724b35ddc898a1c99cb14c31a379af80a\").csv({\n      typed: !0\n    }),\n    pizza: () => new FileAttachment(\"https://static.observableusercontent.com/files/c653108ab176088cacbb338eaf2344c4f5781681702bd6afb55697a3f91b511c6686ff469f3e3a27c75400001a2334dbd39a4499fe46b50a8b3c278b7d2f7fb5\").csv({\n      typed: !0\n    }),\n    weather: () => new FileAttachment(\"https://static.observableusercontent.com/files/693a46b22b33db0f042728700e0c73e836fa13d55446df89120682d55339c6db7cc9e574d3d73f24ecc9bc7eb9ac9a1e7e104a1ee52c00aab1e77eb102913c1f\").csv({\n      typed: !0\n    }),\n    DOM: An,\n    Files: jn,\n    Generators: Ln,\n    Promises: Dn\n  }, Object.fromEntries(Object.entries(n).map(Vn))));\n}, {\n  resolve: {\n    get: () => ft.resolve,\n    enumerable: !0,\n    configurable: !0\n  },\n  require: {\n    get: () => ft,\n    set: function (e) {\n      ft = e;\n    },\n    enumerable: !0,\n    configurable: !0\n  }\n}), {\n  resolveFrom: nt,\n  requireFrom: at\n});\nfunction Vn([e, t]) {\n  return [e, {\n    value: t,\n    writable: !0,\n    enumerable: !0\n  }];\n}\nclass RuntimeError extends Error {\n  constructor(e, t) {\n    super(e), this.input = t;\n  }\n}\nfunction Gn(e) {\n  return () => e;\n}\nfunction Yn(e) {\n  return e;\n}\nRuntimeError.prototype.name = \"RuntimeError\";\nconst Zn = Array.prototype.map;\nfunction Jn() {}\nconst Kn = Symbol(\"no-observer\");\nfunction Variable(e, t, n, r) {\n  var a;\n  n || (n = Kn), Object.defineProperties(this, {\n    _observer: {\n      value: n,\n      writable: !0\n    },\n    _definition: {\n      value: tr,\n      writable: !0\n    },\n    _duplicate: {\n      value: void 0,\n      writable: !0\n    },\n    _duplicates: {\n      value: void 0,\n      writable: !0\n    },\n    _indegree: {\n      value: NaN,\n      writable: !0\n    },\n    _inputs: {\n      value: [],\n      writable: !0\n    },\n    _invalidate: {\n      value: Jn,\n      writable: !0\n    },\n    _module: {\n      value: t\n    },\n    _name: {\n      value: null,\n      writable: !0\n    },\n    _outputs: {\n      value: new Set(),\n      writable: !0\n    },\n    _promise: {\n      value: Promise.resolve(void 0),\n      writable: !0\n    },\n    _reachable: {\n      value: n !== Kn,\n      writable: !0\n    },\n    _rejector: {\n      value: (a = this, e => {\n        if (e === nr) throw e;\n        if (e === tr) throw new RuntimeError(`${a._name} is not defined`, a._name);\n        if (e instanceof Error && e.message) throw new RuntimeError(e.message, a._name);\n        throw new RuntimeError(`${a._name} could not be resolved`, a._name);\n      })\n    },\n    _shadow: {\n      value: Xn(t, r)\n    },\n    _type: {\n      value: e\n    },\n    _value: {\n      value: void 0,\n      writable: !0\n    },\n    _version: {\n      value: 0,\n      writable: !0\n    }\n  });\n}\nfunction Xn(e, t) {\n  return t?.shadow ? new Map(Object.entries(t.shadow).map(([t, n]) => [t, new Variable(2, e).define([], n)])) : null;\n}\nfunction Qn(e) {\n  e._module._runtime._dirty.add(e), e._outputs.add(this);\n}\nfunction er(e) {\n  e._module._runtime._dirty.add(e), e._outputs.delete(this);\n}\nfunction tr() {\n  throw tr;\n}\nfunction nr() {\n  throw nr;\n}\nfunction rr(e) {\n  return () => {\n    throw new RuntimeError(`${e} is defined more than once`);\n  };\n}\nfunction ar(e, t, n) {\n  const r = this._module._scope,\n    a = this._module._runtime;\n  if (this._inputs.forEach(er, this), t.forEach(Qn, this), this._inputs = t, this._definition = n, this._value = void 0, n === Jn ? a._variables.delete(this) : a._variables.add(this), e !== this._name || r.get(e) !== this) {\n    let t, o;\n    if (this._name) if (this._outputs.size) r.delete(this._name), o = this._module._resolve(this._name), o._outputs = this._outputs, this._outputs = new Set(), o._outputs.forEach(function (e) {\n      e._inputs[e._inputs.indexOf(this)] = o;\n    }, this), o._outputs.forEach(a._updates.add, a._updates), a._dirty.add(o).add(this), r.set(this._name, o);else if ((o = r.get(this._name)) === this) r.delete(this._name);else {\n      if (3 !== o._type) throw new Error();\n      o._duplicates.delete(this), this._duplicate = void 0, 1 === o._duplicates.size && (o = o._duplicates.keys().next().value, t = r.get(this._name), o._outputs = t._outputs, t._outputs = new Set(), o._outputs.forEach(function (e) {\n        e._inputs[e._inputs.indexOf(t)] = o;\n      }), o._definition = o._duplicate, o._duplicate = void 0, a._dirty.add(t).add(o), a._updates.add(o), r.set(this._name, o));\n    }\n    if (this._outputs.size) throw new Error();\n    e && ((o = r.get(e)) ? 3 === o._type ? (this._definition = rr(e), this._duplicate = n, o._duplicates.add(this)) : 2 === o._type ? (this._outputs = o._outputs, o._outputs = new Set(), this._outputs.forEach(function (e) {\n      e._inputs[e._inputs.indexOf(o)] = this;\n    }, this), a._dirty.add(o).add(this), r.set(e, this)) : (o._duplicate = o._definition, this._duplicate = n, t = new Variable(3, this._module), t._name = e, t._definition = this._definition = o._definition = rr(e), t._outputs = o._outputs, o._outputs = new Set(), t._outputs.forEach(function (e) {\n      e._inputs[e._inputs.indexOf(o)] = t;\n    }), t._duplicates = new Set([this, o]), a._dirty.add(o).add(t), a._updates.add(o).add(t), r.set(e, t)) : r.set(e, this)), this._name = e;\n  }\n  return this._version > 0 && ++this._version, a._updates.add(this), a._compute(), this;\n}\nObject.defineProperties(Variable.prototype, {\n  _pending: {\n    value: function () {\n      this._observer.pending && this._observer.pending();\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _fulfilled: {\n    value: function (e) {\n      this._observer.fulfilled && this._observer.fulfilled(e, this._name);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _rejected: {\n    value: function (e) {\n      this._observer.rejected && this._observer.rejected(e, this._name);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _resolve: {\n    value: function (e) {\n      return this._shadow?.get(e) ?? this._module._resolve(e);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  define: {\n    value: function (e, t, n) {\n      switch (arguments.length) {\n        case 1:\n          n = e, e = t = null;\n          break;\n        case 2:\n          n = t, \"string\" == typeof e ? t = null : (t = e, e = null);\n      }\n      return ar.call(this, null == e ? null : String(e), null == t ? [] : Zn.call(t, this._resolve, this), \"function\" == typeof n ? n : Gn(n));\n    },\n    writable: !0,\n    configurable: !0\n  },\n  delete: {\n    value: function () {\n      return ar.call(this, null, [], Jn);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  import: {\n    value: function (e, t, n) {\n      arguments.length < 3 && (n = t, t = e);\n      return ar.call(this, String(t), [n._resolve(String(e))], Yn);\n    },\n    writable: !0,\n    configurable: !0\n  }\n});\nconst or = Symbol(\"variable\"),\n  ir = Symbol(\"invalidation\"),\n  sr = Symbol(\"visibility\");\nfunction Module(e, t = []) {\n  Object.defineProperties(this, {\n    _runtime: {\n      value: e\n    },\n    _scope: {\n      value: new Map()\n    },\n    _builtins: {\n      value: new Map([[\"@variable\", or], [\"invalidation\", ir], [\"visibility\", sr], ...t])\n    },\n    _source: {\n      value: null,\n      writable: !0\n    }\n  });\n}\nasync function cr(e, t) {\n  await e._compute();\n  try {\n    return await t._promise;\n  } catch (n) {\n    if (n === nr) return cr(e, t);\n    throw n;\n  }\n}\nfunction lr(e) {\n  return e._name;\n}\nObject.defineProperties(Module.prototype, {\n  _resolve: {\n    value: function (e) {\n      let t,\n        n = this._scope.get(e);\n      if (!n) if (n = new Variable(2, this), this._builtins.has(e)) n.define(e, Gn(this._builtins.get(e)));else if (this._runtime._builtin._scope.has(e)) n.import(e, this._runtime._builtin);else {\n        try {\n          t = this._runtime._global(e);\n        } catch (t) {\n          return n.define(e, function (e) {\n            return () => {\n              throw e;\n            };\n          }(t));\n        }\n        void 0 === t ? this._scope.set(n._name = e, n) : n.define(e, Gn(t));\n      }\n      return n;\n    },\n    writable: !0,\n    configurable: !0\n  },\n  redefine: {\n    value: function (e) {\n      const t = this._scope.get(e);\n      if (!t) throw new RuntimeError(`${e} is not defined`);\n      if (3 === t._type) throw new RuntimeError(`${e} is defined more than once`);\n      return t.define.apply(t, arguments);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  define: {\n    value: function () {\n      const e = new Variable(1, this);\n      return e.define.apply(e, arguments);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  derive: {\n    value: function (e, t) {\n      const n = new Map(),\n        r = new Set(),\n        a = [];\n      function o(e) {\n        let t = n.get(e);\n        return t || (t = new Module(e._runtime, e._builtins), t._source = e, n.set(e, t), a.push([t, e]), r.add(e), t);\n      }\n      const i = o(this);\n      for (const n of e) {\n        const {\n          alias: e,\n          name: r\n        } = \"object\" == typeof n ? n : {\n          name: n\n        };\n        i.import(r, null == e ? r : e, t);\n      }\n      for (const e of r) for (const [t, n] of e._scope) if (n._definition === Yn) {\n        if (e === this && i._scope.has(t)) continue;\n        const r = n._inputs[0]._module;\n        r._source && o(r);\n      }\n      for (const [e, t] of a) for (const [r, a] of t._scope) {\n        const t = e._scope.get(r);\n        if (!t || 2 === t._type) if (a._definition === Yn) {\n          const t = a._inputs[0],\n            o = t._module;\n          e.import(t._name, r, n.get(o) || o);\n        } else e.define(r, a._inputs.map(lr), a._definition);\n      }\n      return i;\n    },\n    writable: !0,\n    configurable: !0\n  },\n  import: {\n    value: function () {\n      const e = new Variable(1, this);\n      return e.import.apply(e, arguments);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  value: {\n    value: async function (e) {\n      let t = this._scope.get(e);\n      if (!t) throw new RuntimeError(`${e} is not defined`);\n      if (t._observer !== Kn) return cr(this._runtime, t);\n      t = this.variable(!0).define([e], Yn);\n      try {\n        return await cr(this._runtime, t);\n      } finally {\n        t.delete();\n      }\n    },\n    writable: !0,\n    configurable: !0\n  },\n  variable: {\n    value: function (e, t) {\n      return new Variable(1, this, e, t);\n    },\n    writable: !0,\n    configurable: !0\n  },\n  builtin: {\n    value: function (e, t) {\n      this._builtins.set(e, t);\n    },\n    writable: !0,\n    configurable: !0\n  }\n});\nconst ur = \"function\" == typeof requestAnimationFrame ? requestAnimationFrame : \"function\" == typeof setImmediate ? setImmediate : e => setTimeout(e, 0);\nfunction Runtime(e = new Library(), t = yr) {\n  const n = this.module();\n  if (Object.defineProperties(this, {\n    _dirty: {\n      value: new Set()\n    },\n    _updates: {\n      value: new Set()\n    },\n    _precomputes: {\n      value: [],\n      writable: !0\n    },\n    _computing: {\n      value: null,\n      writable: !0\n    },\n    _init: {\n      value: null,\n      writable: !0\n    },\n    _modules: {\n      value: new Map()\n    },\n    _variables: {\n      value: new Set()\n    },\n    _disposed: {\n      value: !1,\n      writable: !0\n    },\n    _builtin: {\n      value: n\n    },\n    _global: {\n      value: t\n    }\n  }), e) for (const t in e) new Variable(2, n).define(t, [], e[t]);\n}\nfunction fr(e) {\n  const t = new Set(e._inputs);\n  for (const n of t) {\n    if (n === e) return !0;\n    n._inputs.forEach(t.add, t);\n  }\n  return !1;\n}\nfunction dr(e) {\n  ++e._indegree;\n}\nfunction pr(e) {\n  --e._indegree;\n}\nfunction mr(e) {\n  return e._promise.catch(e._rejector);\n}\nfunction hr(e) {\n  return new Promise(function (t) {\n    e._invalidate = t;\n  });\n}\nfunction br(e, t) {\n  let n,\n    r,\n    a = \"function\" == typeof IntersectionObserver && t._observer && t._observer._node,\n    o = !a,\n    i = Jn,\n    s = Jn;\n  return a && (r = new IntersectionObserver(([e]) => (o = e.isIntersecting) && (n = null, i())), r.observe(a), e.then(() => (r.disconnect(), r = null, s()))), function (e) {\n    return o ? Promise.resolve(e) : r ? (n || (n = new Promise((e, t) => (i = e, s = t))), n.then(() => e)) : Promise.reject();\n  };\n}\nfunction wr(e) {\n  e._invalidate(), e._invalidate = Jn, e._pending();\n  const t = e._value,\n    n = ++e._version;\n  let r = null;\n  const a = e._promise = (e._inputs.length ? Promise.all(e._inputs.map(mr)).then(function (a) {\n    if (e._version !== n) throw nr;\n    for (let t = 0, n = a.length; t < n; ++t) switch (a[t]) {\n      case ir:\n        a[t] = r = hr(e);\n        break;\n      case sr:\n        r || (r = hr(e)), a[t] = br(r, e);\n        break;\n      case or:\n        a[t] = e;\n    }\n    return e._definition.apply(t, a);\n  }) : new Promise(n => n(e._definition.call(t)))).then(function (t) {\n    if (e._version !== n) throw nr;\n    if (function (e) {\n      return e && \"function\" == typeof e.next && \"function\" == typeof e.return;\n    }(t)) return (r || hr(e)).then((a = t, function () {\n      a.return();\n    })), function (e, t, n) {\n      const r = e._module._runtime;\n      let a;\n      function o(e) {\n        return new Promise(e => e(n.next(a))).then(({\n          done: t,\n          value: n\n        }) => t ? void 0 : Promise.resolve(n).then(e));\n      }\n      function i() {\n        const n = o(o => {\n          if (e._version !== t) throw nr;\n          return a = o, s(o, n).then(() => r._precompute(i)), e._fulfilled(o), o;\n        });\n        n.catch(r => {\n          r !== nr && e._version === t && (s(void 0, n), e._rejected(r));\n        });\n      }\n      function s(t, n) {\n        return e._value = t, e._promise = n, e._outputs.forEach(r._updates.add, r._updates), r._compute();\n      }\n      return o(n => {\n        if (e._version !== t) throw nr;\n        return a = n, r._precompute(i), n;\n      });\n    }(e, n, t);\n    var a;\n    return t;\n  });\n  a.then(t => {\n    e._value = t, e._fulfilled(t);\n  }, t => {\n    t !== nr && (e._value = void 0, e._rejected(t));\n  });\n}\nfunction vr(e, t) {\n  e._invalidate(), e._invalidate = Jn, e._pending(), ++e._version, e._indegree = NaN, (e._promise = Promise.reject(t)).catch(Jn), e._value = void 0, e._rejected(t);\n}\nfunction yr(e) {\n  return globalThis[e];\n}\nObject.defineProperties(Runtime.prototype, {\n  _precompute: {\n    value: function (e) {\n      this._precomputes.push(e), this._compute();\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _compute: {\n    value: function () {\n      return this._computing || (this._computing = this._computeSoon());\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _computeSoon: {\n    value: function () {\n      return new Promise(ur).then(() => this._disposed ? void 0 : this._computeNow());\n    },\n    writable: !0,\n    configurable: !0\n  },\n  _computeNow: {\n    value: async function () {\n      let e,\n        t,\n        n = [],\n        r = this._precomputes;\n      if (r.length) {\n        this._precomputes = [];\n        for (const e of r) e();\n        await function (e = 0) {\n          let t = Promise.resolve();\n          for (let n = 0; n < e; ++n) t = t.then(() => {});\n          return t;\n        }(3);\n      }\n      e = new Set(this._dirty), e.forEach(function (t) {\n        t._inputs.forEach(e.add, e);\n        const n = function (e) {\n          if (e._observer !== Kn) return !0;\n          const t = new Set(e._outputs);\n          for (const e of t) {\n            if (e._observer !== Kn) return !0;\n            e._outputs.forEach(t.add, t);\n          }\n          return !1;\n        }(t);\n        n > t._reachable ? this._updates.add(t) : n < t._reachable && t._invalidate(), t._reachable = n;\n      }, this), e = new Set(this._updates), e.forEach(function (t) {\n        t._reachable ? (t._indegree = 0, t._outputs.forEach(e.add, e)) : (t._indegree = NaN, e.delete(t));\n      }), this._computing = null, this._updates.clear(), this._dirty.clear(), e.forEach(function (e) {\n        e._outputs.forEach(dr);\n      });\n      do {\n        for (e.forEach(function (e) {\n          0 === e._indegree && n.push(e);\n        }); t = n.pop();) wr(t), t._outputs.forEach(a), e.delete(t);\n        e.forEach(function (t) {\n          fr(t) && (vr(t, new RuntimeError(\"circular definition\")), t._outputs.forEach(pr), e.delete(t));\n        });\n      } while (e.size);\n      function a(e) {\n        0 == --e._indegree && n.push(e);\n      }\n    },\n    writable: !0,\n    configurable: !0\n  },\n  dispose: {\n    value: function () {\n      this._computing = Promise.resolve(), this._disposed = !0, this._variables.forEach(e => {\n        e._invalidate(), e._version = NaN;\n      });\n    },\n    writable: !0,\n    configurable: !0\n  },\n  module: {\n    value: function (e, t = Jn) {\n      let n;\n      if (void 0 === e) return (n = this._init) ? (this._init = null, n) : new Module(this);\n      if (n = this._modules.get(e), n) return n;\n      this._init = n = new Module(this), this._modules.set(e, n);\n      try {\n        e(this, t);\n      } finally {\n        this._init = null;\n      }\n      return n;\n    },\n    writable: !0,\n    configurable: !0\n  },\n  fileAttachments: {\n    value: function (e) {\n      return Object.assign(t => {\n        const n = e(t += \"\");\n        if (null == n) throw new Error(`File not found: ${t}`);\n        if (\"object\" == typeof n && \"url\" in n) {\n          const {\n            url: e,\n            mimeType: r\n          } = n;\n          return new FileAttachment(e, t, r);\n        }\n        return new FileAttachment(n, t);\n      }, {\n        prototype: FileAttachment.prototype\n      });\n    },\n    writable: !0,\n    configurable: !0\n  }\n});\n\n\n//# sourceURL=webpack://@jazztap/dendryscope-demo/./src/runtime.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		// The chunk loading function for additional chunks
/******/ 		// Since all referenced chunks are already included
/******/ 		// in this file, this function is empty here.
/******/ 		__webpack_require__.e = () => (Promise.resolve());
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;